<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Demystifying Pratt Parsers</title>
    <link rel="modulepreload" crossorigin href="/elm.1a2cc1f4.js"><link rel="modulepreload" crossorigin href="/assets/index-C9SU9G8M.js">
    <script defer src="/elm.1a2cc1f4.js" type="text/javascript"></script>
        
    <meta name="generator" content="elm-pages v3.0.20" />
    
        <link rel="canonical" href="https://hahnah.github.io/try-elm-pages-2" />    <meta name="description" content="Pratt parsers are a beautiful way of solving the operator precedence problem." />    <meta property="og:image" content="https://hahnah.github.io/try-elm-pages-2/media/blog-image.png" />    <meta property="og:image:secure_url" content="https://hahnah.github.io/try-elm-pages-2/media/blog-image.png" />    <meta property="og:image:alt" content="Demystifying Pratt Parsers" />    <meta property="og:title" content="Demystifying Pratt Parsers" />    <meta property="og:url" content="https://hahnah.github.io/try-elm-pages-2" />    <meta property="og:description" content="Pratt parsers are a beautiful way of solving the operator precedence problem." />    <meta property="og:site_name" content="elm blog" />    <meta property="twitter:card" content="summary_large_image" />    <meta property="twitter:title" content="Demystifying Pratt Parsers" />    <meta property="twitter:description" content="Pratt parsers are a beautiful way of solving the operator precedence problem." />    <meta property="twitter:image" content="https://hahnah.github.io/try-elm-pages-2/media/blog-image.png" />    <meta property="twitter:image:alt" content="Demystifying Pratt Parsers" />    <meta property="og:type" content="website" />    <meta name="twitter:label1" content="Authors" />    <meta name="twitter:data1" content="Martin Janiczek, Franklin Frisby" />    <meta name="twitter:label2" content="Reading time" />    <meta name="twitter:data2" content="19 min" />    <meta name="viewport" content="width=device-width,initial-scale=1" />    <link rel="sitemap" type="application/xml" href="/sitemap.xml" />
                  <script id="__ELM_PAGES_BYTES_DATA__" type="application/octet-stream">AQn8lT4KIyMgVEw7RFIKCkhlcmUncyB0aGUgYWxnb3JpdGhtIGZvciBgcHJhdHQocHJlY0xpbWl0KWA6CgpbIVtQcmF0dCBwYXJzZXIgYWxnb3JpdGhtXSgvY29udGVudC90ZWNoLWJsb2cvcHJhdHQtcGFyc2Vycy9hc3NldHMvYWxnb3JpdGhtLnBuZyldKC9pbWFnZXMvcHJhdHQtcGFyc2Vycy9hbGdvcml0aG0ucG5nKQoKW0hlcmUncyBhIG1pbmltYWwgY29tbWVudGVkIFByYXR0IHBhcnNlciBleGFtcGxlIGluIEVsbS5dKGh0dHBzOi8vZWxsaWUtYXBwLmNvbS9uZktCeHBLSjVwdmExKQoKIyMgVGFibGUgb2YgY29udGVudHMKCi0gW0ludHJvZHVjdGlvbl0oI2ludHJvZHVjdGlvbikKLSBbQm9iIE55c3Ryb20ncyBhcnRpY2xlXSgjYm9iLW55c3Ryb21zLWFydGljbGUpCi0gW092ZXJ2aWV3XSgjb3ZlcnZpZXcpCi0gW1Zpc3VhbCBpbnR1aXRpb25dKCN2aXN1YWwtaW50dWl0aW9uKQotIFtXYWxrLXRocm91Z2ggZXhhbXBsZV0oI3dhbGstdGhyb3VnaC1leGFtcGxlKQotIFtFbG0gaW1wbGVtZW50YXRpb25dKCNlbG0taW1wbGVtZW50YXRpb24pCi0gW0xvb3NlIHRocmVhZHNdKCNsb29zZS10aHJlYWRzKQotIFtDb25jbHVzaW9uXSgjY29uY2x1c2lvbikKCiMjIEludHJvZHVjdGlvbgoKUHJhdHQgcGFyc2VycyBhcmUgYSBiZWF1dGlmdWwgd2F5IG9mIHNvbHZpbmcgdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcHJvYmxlbToKCkhvdyBjYW4gYW4gZXhwcmVzc2lvbiBsaWtlIGAxKzItMyo0KzUvNl43LTgqOWAgYmUgcGFyc2VkIHRvIG1lZXQgdGhlIGV4cGVjdGF0aW9ucyBvZiB5b3VyIFtQRU1EQVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09yZGVyX29mX29wZXJhdGlvbnMjTW5lbW9uaWNzKS10cmFpbmVkIGJyYWluPyBXaGVyZSBkbyB5b3UgcHV0IHRoZSBwYXJlbnRoZXNlcz8gX1doYXQgZ29lcyBmaXJzdD9fCgpUaGUgdW5kZXJseWluZyBwcm9ibGVtIGlzIHRoZSBmcmVxdWVudCBhbWJpZ3VpdHkgaW4gY29tYmluYXRpb25zIG9mIG9wZXJhdG9ycy4gRm9yIGV4YW1wbGUsIGhvdyBzaG91bGQgdGhlIGV4cHJlc3Npb24gYDErMiozYCBiZSBpbnRlcnByZXRlZD8KClRoZXJlIGFyZSB0d28gb3B0aW9ucywgZWFjaCBsZWFkaW5nIHRvIGEgZGlmZmVyZW50IHZhbHVlLgoKIVtBbWJpZ3VpdHkgb2YgbXVsdGlwbGUgYmluYXJ5IG9wZXJhdG9yc10oL2NvbnRlbnQvdGVjaC1ibG9nL3ByYXR0LXBhcnNlcnMvYXNzZXRzL2FtYmlndWl0eS5wbmcpCgpUaGVyZSBhcmUgW2EgZmV3IGFsZ29yaXRobXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09wZXJhdG9yLXByZWNlZGVuY2VfcGFyc2VyKSB0byBzb2x2ZSB0aGlzIHByb2JsZW0uIEFtb25nIHRoZW0sIG15IGZhdm9yaXRlIGlzIHRoZSBbUHJhdHQgcGFyc2VyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRvci1wcmVjZWRlbmNlX3BhcnNlciNQcmF0dF9wYXJzaW5nKS0tLXRoZSBtb3N0IGludHVpdGl2ZSBhbmQgZGVjbGFyYXRpdmUgc29sdXRpb24gaW4gbXkgdmlldy4KClByYXR0IHBhcnNlcnMgYXJlIGFuIGFsZ29yaXRobSB0aGF0IHRha2VzIHlvdXIgdG9rZW5zIChgWzEsICssIDIsICosIDNdYCkgYW5kIGEgdGFibGUgbGlrZToKCnwgT3BlcmF0b3IgfCBQcmVjZWRlbmNlIHwKfCAtLS0tLS0tLSB8IC0tLS0tLS0tLS0gfAp8ICsgICAgICAgIHwgMSAgICAgICAgICB8CnwgLSAgICAgICAgfCAxICAgICAgICAgIHwKfCBcKiAgICAgICB8IDIgICAgICAgICAgfAp8IC8gICAgICAgIHwgMiAgICAgICAgICB8CnwgXiAgICAgICAgfCAzICAgICAgICAgIHwKCmFuZCBzcGl0IG91dCB0aGUgY29ycmVjdGx5IHBhcmVudGhlc2l6ZWQvbmVzdGVkIGV4cHJlc3Npb24gKGAxICsgKDIgKiAzKWApLiBTbyBuaWNlIQoKQnV0IF9ob3cgZG8gdGhleSB3b3JrP18KCiMjIEJvYiBOeXN0cm9tJ3MgYXJ0aWNsZQoKVGhlIG9yaWdpbmFsIHBhcGVyIF8iVG9wIERvd24gT3BlcmF0b3IgUHJlY2VkZW5jZSJfIChbUERGXShodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNTEyMjMyMTU0MjEvaHR0cDovL2hhbGwub3JnLnVhL2hhbGxzL3dpenphcmQvcGRmL1ZhdWdoYW4uUHJhdHQuVERPUC5wZGYpIG9yIHRoaXMgYmVhdXRpZnVsIFtIVE1MIHJlbmRlcmluZ10oaHR0cHM6Ly90ZG9wLmdpdGh1Yi5pbykpIGJ5IFZhdWdoYW4gUHJhdHQgaGFzIGEgbG90IG9mIHRoZW9yeSwgdGhlb3JlbXMgYW5kIHByb29mcywgaXMgc29tZXdoYXQgcGhpbG9zb3BoaWNhbCBhdCB0aW1lcywgYW5kIHNwZW5kcyBxdWl0ZSBzb21lIHRpbWUgZGVhbGluZyB3aXRoIHByb2JsZW1zIG9mIGl0cyB0aW1lICgxOTczKS4KCk9mIGNvdXJzZSwgYXMgYW4gYWNhZGVtaWMgcGFwZXIgaXQgaGFzIGEgZGlmZmVyZW50IHRhcmdldCBhdWRpZW5jZSwgc28gbGV0J3Mgbm90IGhvbGQgdGhhdCBhZ2FpbnN0IGl0LiBJdCBhbHNvIG1ha2VzIHNlbnNlIGZvciBpdCAoaW50cm9kdWNpbmcgYSBuZXcgaWRlYSkgdG8gZGlzY3VzcyBtb3RpdmF0aW9uLiBCdXQgdGhhdCBtYWtlcyBpdCBhbGwgdGhlIGhhcmRlciB0byBmaW5kIHRoZSBpbXBvcnRhbnQgcGFydHMgaW4gdGhlIHBhcGVyLgoKQW5kIEkgc3VzcGVjdCB0aGF0J3MgdGhlIHJlYXNvbiBwZW9wbGUgd3JpdGUgc3VtbWFyaWVzLiBZb3UgZG9uJ3QgbmVlZCB0aGUgMTk3MyBtb3RpdmF0aW9uLCB5b3UganVzdCBuZWVkIHRvIF9zb2x2ZSB0aGUgb3BlcmF0b3IgcHJlY2VkZW5jZSBwcm9ibGVtIV8KClRoZSBiZXN0IHN1bW1hcnkgYW5kIGV4cGxhbmF0aW9uIG9mIFByYXR0IHBhcnNlcnMgSSBrbm93IG9mIChhdCBsZWFzdCBmb3IgdGhlIGF1ZGllbmNlIG9mIGFuIGFtYXRldXIgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UgZGVzaWduZXIgaW4gMjAyMykgaXMgd3JpdHRlbiBieSBbQm9iIE55c3Ryb21dKGh0dHBzOi8vdHdpdHRlci5jb20vbXVuaWZpY2VudGJvYikgaW4gaGlzIGJsb2dwb3N0IFtfIlByYXR0IFBhcnNlcnM6IEV4cHJlc3Npb24gUGFyc2luZyBNYWRlIEVhc3kiX10oaHR0cHM6Ly9qb3VybmFsLnN0dWZmd2l0aHN0dWZmLmNvbS8yMDExLzAzLzE5L3ByYXR0LXBhcnNlcnMtZXhwcmVzc2lvbi1wYXJzaW5nLW1hZGUtZWFzeS8pLiBZb3Ugc2hvdWxkIGRlZmluaXRlbHkgcmVhZCBpdCEgKEFsb25nIHdpdGggb3RoZXIgQm9iJ3Mgd3JpdGluZ3MsIGxpa2UgW19DcmFmdGluZyBJbnRlcnByZXRlcnNfXShodHRwczovL2NyYWZ0aW5naW50ZXJwcmV0ZXJzLmNvbSkuKQoKVGhlIGV4YW1wbGVzIEJvYiBnaXZlcyBhcmUgd3JpdHRlbiBpbiBKYXZhLCBhbmQgdGhlIFtmdWxsIGV4YW1wbGUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9tdW5pZmljZW50L2JhbnRhbSkgaXMgc3BsaXQgYWNyb3NzIG11bHRpcGxlIHNtYWxsIGNsYXNzZXMuCgpJIGZlZWwgdGhhdCB3ZSBjYW4gZG8gYSBiaXQgYmV0dGVyIHBlZGFnb2dpY2FsbHktLS1pdCBjYW4gYmUgdHJpY2t5IG1ha2luZyBzZW5zZSBvZiB0aGUgaWRlYSB3aGVuIHNwcmVhZCBvdXQgbGlrZSB0aGlzLCBhbmQgaXQgY2FuIGFsc28gYmUgY2hhbGxlbmdpbmcgdG8gcG9ydCB0aGUgaWRlYSBmcm9tIE9PUCB0byBhIEZQIGxhbmd1YWdlLgoKTm90IHRoYXQgeW91J2QgYmUgdW5hYmxlIHRvIG1ha2Ugc2Vuc2Ugb2YgdGhlIEphdmEgY29kZSwgYnV0IEkgc2VlIHBlZGFnb2dpY2FsIHZhbHVlIGluIHRyeWluZyB0byBzaW1wbGlmeSBfZXZlbiBtb3JlLl8KClNvLCB0aGF0J3MgbXkgbW90aXZhdGlvbiBmb3Igd3JpdGluZyB0aGlzIGFydGljbGUhIExldCdzIHRyeSBhbmQgc2VlIGhvdyB3b3VsZCBhIG1vcmUgbWluaW1hbCBhbmQgY29uY2lzZSBpbXBsZW1lbnRhdGlvbiBsb29rIGluIFtFbG1dKGh0dHBzOi8vZWxtLWxhbmcub3JnLykhCgo+IFNwb2lsZXI6IFtfaGVyZSBpdCBpcy5fXShodHRwczovL2VsbGllLWFwcC5jb20vbmZLQnhwS0o1cHZhMSkKClRoZSBsYW5ndWFnZSBpcyBwdXJlLCBpbW11dGFibGUsIGhhcyBubyBlc2NhcGUgaGF0Y2hlcywgaGFzIG5vIHNwb29reSBhY3Rpb24gYXQgYSBkaXN0YW5jZSAoZWcuIGRlZmF1bHQgYXJndW1lbnRzIG9yIGV4Y2VwdGlvbnMpIGFuZCBubyBvYnNjdXJlIGZlYXR1cmVzIChleGNlcHQgZm9yIHBlcmhhcHMgW3N1bSB0eXBlc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGFnZ2VkX3VuaW9uKSwgYnV0IGV2ZW4gdGhvc2UgYXJlIHRoYW5rZnVsbHkgZ2V0dGluZyBtb3JlIGFuZCBtb3JlIGNvbW1vbiBpbiBvdGhlciBsYW5ndWFnZXMpLgoKSGVuY2UsIGlmIHlvdSBjYW4gd3JpdGUgaXQgaW4gRWxtLCB5b3UgY2FuIGxpa2VseSB3cml0ZSBpdCBpbiBhbnl0aGluZyBlbHNlLgoKIyMgT3ZlcnZpZXcKClRoZSBpZGVhIG9mIFByYXR0IHBhcnNpbmcgaXMgdmVyeSBzaW1wbGU6CgpFYWNoIG9wZXJhdG9yIGhhcyBfYSBwcmVjZWRlbmNlXyAoYSBudW1iZXIpIGFzc29jaWF0ZWQgd2l0aCBpdC4gTGFyZ2VyIG51bWJlciBtZWFucyBoaWdoZXIgcHJpb3JpdHksIGVnLiBtdWx0aXBsaWNhdGlvbiBoYXMgaGlnaGVyIHByaW9yaXR5IHRoYW4gYWRkaXRpb24uCgpUaGUgUHJhdHQgcGFyc2VyIGhvbGRzIF9hIHByZWNlZGVuY2UgbGltaXRfLiBJdCBjYW4gYmUgdGhvdWdodCBvZiBhczogIllvdSdyZSBvbmx5IGFsbG93ZWQgdG8gcGFyc2Ugb3BlcmF0b3JzIHdpdGggcHJlY2VkZW5jZSBfaGlnaGVyXyB0aGFuIHRoaXMgbnVtYmVyLiIKCj4gVGhlIHByZWNlZGVuY2UgbGltaXQgb2YgdGhlIHRvcC1sZXZlbCBleHByZXNzaW9uIGlzIDAuIFRodXMgeW91IGNvdWxkIGRlZmluZSB5b3VyIGBleHByKHRva2VucylgIHBhcnNlciBhcyBgcHJhdHQoMCx0b2tlbnMpYC4KClRoZSBQcmF0dCBwYXJzZXIgZmlyc3QgcGFyc2VzIGEgcHJlZml4IGV4cHJlc3Npb24gKHRoZSBfbGVmdF8gcGFydCBvZiB0aGUgYE9wKGxlZnQsIG9wLCByaWdodClgKSwgdGhlbiBzdGFydHMgYSBsb29wLgoKSW4gdGhlIGxvb3AgaXQgbG9va3MgYXQgdGhlIG5leHQgdG9rZW4uIElmIHRoZXJlIGFyZSBubyB0b2tlbnMgbGVmdCwgb3IgaWYgaXQncyBub3QgYSBrbm93biBiaW5hcnkgb3BlcmF0b3IsIG9yIGlmIGl0IF9pc18gYnV0IGl0cyBwcmVjZWRlbmNlIGlzIGVxdWFsIG9yIGxvd2VyIHRoYW4gdGhlIGxpbWl0LCB0aGUgcGFyc2VyIGVuZHMgYW5kIHJldHVybnMgdGhlIGxlZnQgZXhwcmVzc2lvbiwgYWxvbmdzaWRlIGFuIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgdG9rZW4gdG8gbG9vayBhdCBuZXh0ICg9IHdoYXRldmVyJ3MgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGxlZnQgZXhwcmVzc2lvbikuCgpJZiB0aGUgdG9rZW4gaXMgYSBrbm93biBiaW5hcnkgb3BlcmF0b3Igd2l0aCBfaGlnaGVyXyBwcmVjZWRlbmNlIHRoYW4gdGhlIGxpbWl0IGhlbGQgYnkgdGhlIFByYXR0IHBhcnNlciwgdGhlIHBhcnNlciBzcGF3bnMgYW5vdGhlciBQcmF0dCBwYXJzZXIgd2l0aCBhIGxpbWl0IGVxdWFsIHRvIHRoZSBvcGVyYXRvcidzIHByZWNlZGVuY2UuCgpXaGF0ZXZlciB0aGF0IGlubmVyIFByYXR0IHBhcnNlciByZXR1cm5zICh0aGUgX3JpZ2h0XyBwYXJ0IG9mIHRoZSBvcCksIHRoZSBvdXRlciBvbmUgY29tYmluZXMgaW50byBgT3AobGVmdCwgb3AsIHJpZ2h0KWAgd2hpY2ggYmVjb21lcyB0aGUgX2xlZnRfIGZvciB0aGUgbmV4dCBsb29wLgoKVGhhdCB3YXkgdGhlIFByYXR0IHBhcnNlciBtYW5hZ2VzIHRvIGNvbnN1bWUgYWxsIG9wZXJhdGlvbnMgYWJvdmUgaXRzIGxpbWl0LiBBIFByYXR0IHBhcnNlciBjb25zdW1pbmcgYCpgIGFuZCBgL2Agd2lsbCBhbHNvIGNvbnN1bWUgYF5gIGludG8gYSAocGFyZW50aGVzaXplZCkgY2hpbGQgdmlhIHRoZSBuZXN0ZWQgYHByYXR0KC4uLilgIGNhbGxzLCBidXQgd2lsbCBuZXZlciB0b3VjaCBgK2AgYW5kIGAtYC4KCi4uLldlbGwsIHRoYXQgd2FzIGEgbW91dGhmdWwuIEhlcmUgaXQgaXMgaW4gdGhlIGZsb3djaGFydCBmb3JtIGFnYWluOgoKWyFbUHJhdHQgcGFyc2VyIGFsZ29yaXRobV0oL2NvbnRlbnQvdGVjaC1ibG9nL3ByYXR0LXBhcnNlcnMvYXNzZXRzL2FsZ29yaXRobS5wbmcpXSgvaW1hZ2VzL3ByYXR0LXBhcnNlcnMvYWxnb3JpdGhtLnBuZykKCkkgd291bGRuJ3QgYmxhbWUgeW91IGlmIGl0IGRpZG4ndCBjbGljayByaWdodCBhd2F5ISBUbyBhaWQgdW5kZXJzdGFuZGluZywgbGV0J3MgZXhhbWluZSB3aGF0IHRoZSBhbGdvcml0aG0gZG9lcyBmcm9tIGEgZmV3IGRpZmZlcmVudCBwZXJzcGVjdGl2ZXM6IHZpc3VhbGx5LCB0aGVuIHJlYWRpbmcgdGhyb3VnaCBhbiBleGVjdXRpb24gdHJhY2UsIGFuZCB0aGVuIGZpbmFsbHkgdGhlIGNvZGUgaXRzZWxmLgoKIyMgVmlzdWFsIGludHVpdGlvbgoKSGVyZSdzIHRoZSBleHByZXNzaW9uIHdlJ3JlIGludGVyZXN0ZWQgaW4gcGFyc2luZzoKCiFbT3JpZ2luYWwgZXhwcmVzc2lvbl0oL2NvbnRlbnQvdGVjaC1ibG9nL3ByYXR0LXBhcnNlcnMvYXNzZXRzL3NvdXJjZS5wbmcpCgpJZiB3ZSBmb2N1cyBvbiBfYWRkaW5nIHBhcmVudGhlc2VzXyAoaW5zdGVhZCBvZiB0cmVlIGNyZWF0aW9uKSwgd2Ugd2FudCB0byBlbmQgdXAgd2l0aCBzb21ldGhpbmcgc2ltaWxhciB0byB0aGUgZm9sbG93aW5nOgoKIVtFeHByZXNzaW9uIHdpdGggYWRkZWQgcGFyZW50aGVzZXNdKC9jb250ZW50L3RlY2gtYmxvZy9wcmF0dC1wYXJzZXJzL2Fzc2V0cy9wYXJlbnRoZXNpemVkLnBuZykKCkxldCdzIGFzc2lnbiB0aGUgcHJlY2VkZW5jZSB2YWx1ZXMgdG8gdGhlIG9wZXJhdG9yczoKCnwgT3BlcmF0b3IgfCBQcmVjZWRlbmNlIHwKfCAtLS0tLS0tLSB8IC0tLS0tLS0tLS0gfAp8ICsgICAgICAgIHwgMSAgICAgICAgICB8CnwgLSAgICAgICAgfCAxICAgICAgICAgIHwKfCBcKiAgICAgICB8IDIgICAgICAgICAgfAp8IC8gICAgICAgIHwgMiAgICAgICAgICB8CnwgXiAgICAgICAgfCAzICAgICAgICAgIHwKCk5vdyBsZXQncyBwdXQgb3BlcmF0b3JzIG9uIHNlcGFyYXRlIGxpbmVzIGFjY29yZGluZyB0byB0aGVpciBwcmVjZWRlbmNlOgoKIVtTZXBhcmF0ZWRdKC9jb250ZW50L3RlY2gtYmxvZy9wcmF0dC1wYXJzZXJzL2Fzc2V0cy9zZXBhcmF0ZWQucG5nKQoKSW4gb3JkZXIgdG8gZ2V0IHNvbWUgdmlzdWFsIGludHVpdGlvbiBvbiB0aGlzIHByb2JsZW0sIHdlJ2xsIHJlcGVhdCBhIHNpbXBsZSBwcm9jZXNzIG9uIGVhY2ggbGV2ZWw6IGdpdmVuIGEgcmVnaW9uIGluIGEgbGV2ZWwgYWJvdmUsIHdlJ2xsIGRyYXcgcmVnaW9ucyBfYmV0d2Vlbl8gdGhlIG9wZXJhdG9ycyBvbiBvdXIgY3VycmVudCBsZXZlbDoKCiFbUHJvY2VzcyB3ZSdsbCBmb2xsb3ddKC9jb250ZW50L3RlY2gtYmxvZy9wcmF0dC1wYXJzZXJzL2Fzc2V0cy9wcm9jZXNzLnBuZykKCkF0IHRoZSB2ZXJ5IHRvcCAoYHA9MGApIHdlJ2xsIHN0YXJ0IHdpdGggb25lIGxhcmdlIHJlZ2lvbjoKCiFbcD0wXSgvY29udGVudC90ZWNoLWJsb2cvcHJhdHQtcGFyc2Vycy9hc3NldHMvcDAucG5nKQoKT25lIGxldmVsIGJlbG93IChgcD0xYCksIHdlIHNwbGl0IHRoZSByZWdpb24gd2hlbmV2ZXIgd2UgZW5jb3VudGVyIGFuIG9wZXJhdG9yIG9uIG91ciBsZXZlbC0tLXRoYXQgaXMsIGArYCBvciBgLWAuCgohW3A9MV0oL2NvbnRlbnQvdGVjaC1ibG9nL3ByYXR0LXBhcnNlcnMvYXNzZXRzL3AxLnBuZykKCkNvbnRpbnVpbmcgb24gdG8gYHA9MmAsIHdlJ2xsIHNwbGl0IGVhY2ggYmx1ZSByZWdpb24gd2hlbiB3ZSBmaW5kIGAqYCBvciBgL2AuCgo+IFRvIG1ha2UgdGhlIGRpYWdyYW0gbGVzcyBjbHV0dGVyZWQsIHdlJ2xsIHNraXAgcHJvY2Vzc2luZyByZWdpb25zIHdpdGggc2luZ2xlIG51bWJlcnMsIGVnLiBoZXJlIGAxYCBhbmQgYDJgLgoKIVtwPTJdKC9jb250ZW50L3RlY2gtYmxvZy9wcmF0dC1wYXJzZXJzL2Fzc2V0cy9wMi5wbmcpCgpBbmQgdGhlbiBmaW5hbGx5IG9uIGxldmVsIGBwPTNgIHdlIHNwbGl0IHRoZSByZWdpb24gY29udGFpbmluZyB0aGUgYF5gLgoKIVtwPTNdKC9jb250ZW50L3RlY2gtYmxvZy9wcmF0dC1wYXJzZXJzL2Fzc2V0cy9wMy5wbmcpCgpCeSBub3cgcGVyaGFwcyB5b3UgYWxyZWFkeSBzZWUgd2hhdCdzIGhhcHBlbmluZzogX2VhY2ggYmx1ZSByZWdpb24gcmVwcmVzZW50cyBhIHNldCBvZiBwYXJlbnRoZXNlcyFfCgpMZXQncyBjbGVhbiB0aGUgZGlhZ3JhbSB1cCBhIGxpdHRsZSBiZWZvcmUgd2Ugc2hvdyB0aGF0IG9mZjogcGFyZW50aGVzZXMgd2l0aCBubyBvcGVyYXRvcnMgaW5zaWRlIGFyZW4ndCB2ZXJ5IGhlbHBmdWwgKGVnLiBgKDMpYCB2cyBgM2ApLCBzbyB3ZSdsbCByZW1vdmUgdGhlIGJsdWUgcmVnaW9ucyB0aGF0IG9ubHkgaG9sZCBzaW5nbGUgbnVtYmVyczoKCiFbQ2xlYW5lZCB1cF0oL2NvbnRlbnQvdGVjaC1ibG9nL3ByYXR0LXBhcnNlcnMvYXNzZXRzL2NsZWFuZWR1cC5wbmcpCgpBbmQgbm93IHdlIGNhbiBmaW5hbGx5IHJlcGxhY2UgZWFjaCBiZWdpbm5pbmcgb2YgYSBibHVlIHJlZ2lvbiB3aXRoIGAoYCBhbmQgZWFjaCBlbmQgd2l0aCBgKWA6CgohW0NvbnZlcnRlZF0oL2NvbnRlbnQvdGVjaC1ibG9nL3ByYXR0LXBhcnNlcnMvYXNzZXRzL2NvbnZlcnRlZC5wbmcpCgpNZXJnaW5nIGVhY2ggbGV2ZWwgaW50byB0aGUgb25lIGFib3ZlLCB3ZSBlbmQgdXAgd2l0aCB0aGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHdlIHdhbnRlZDoKCiFbTWVyZ2VkXSgvY29udGVudC90ZWNoLWJsb2cvcHJhdHQtcGFyc2Vycy9hc3NldHMvcGFyZW50aGVzaXplZC5wbmcpCgpXaGF0IHdlIGhhdmUgYmVlbiBkb2luZyB2aXN1YWxseSwgY29ycmVzcG9uZHMgdG8gdGhlIFByYXR0IHBhcnNlciBhbGdvcml0aG06IHRoZSBibHVlIHJlZ2lvbnMgb24gbGV2ZWwgYHA9bmAgYXJlIGNhbGxzIHRvIHRoZSBgcHJhdHQobilgIHBhcnNlci4gKEV4Y2VwdCBmb3IgdGhlIGxlZnRtb3N0IG51bWJlcnMgb2YgZWFjaCBibG9jaywgd2hpY2ggYXJlIGhhbmRsZWQgYnkgdGhlIGBwcmVmaXhgIHBhcnNlci4pCgpMZXQncyBub3cgd2FsayB0aHJvdWdoIHRoZSBhbGdvcml0aG0gb24gYW4gZXhhbXBsZSB0byBzZWUgdGhhdC4gXyhJIHN3ZWFyIHRoZXJlJ3MgZ29pbmcgdG8gYmUgc29tZSBjb2RlIGluIHRoaXMgYmxvZ3Bvc3QgZXZlbnR1YWxseS4pXwoKIyMgV2Fsay10aHJvdWdoIGV4YW1wbGUKClRoZSBzb3VyY2Ugd2UncmUgdHJ5aW5nIHRvIHBhcnNlIGlzIGAxKzItMyo0KzUvNl43LTgqOWAuCgpJdCBjb3JyZXNwb25kcyB0byBhIHNlcXVlbmNlIG9mIHRva2VuczoKCmBgYGVsbQpbIDEsICssIDIsIC0sIDMsICosIDQsICssIDUsIC8sIDYsIF4sIDcsIC0sIDgsICosIDkgXQpgYGAKClRoZSBwcmVjZWRlbmNlcyBhcmUgYXMgZm9sbG93czoKCnwgT3BlcmF0b3IgfCBQcmVjZWRlbmNlIHwKfCAtLS0tLS0tLSB8IC0tLS0tLS0tLS0gfAp8ICsgICAgICAgIHwgMSAgICAgICAgICB8CnwgLSAgICAgICAgfCAxICAgICAgICAgIHwKfCBcKiAgICAgICB8IDIgICAgICAgICAgfAp8IC8gICAgICAgIHwgMiAgICAgICAgICB8CnwgXiAgICAgICAgfCAzICAgICAgICAgIHwKCj4gSW4gdGhpcyBzaW1wbGlmaWVkIGV4YW1wbGUsIHRoZXJlIGFyZSBubyB1bmFyeSBvcGVyYXRvcnMuIFdlJ2xsIHRhbGsgYWJvdXQgdGhvc2UgbmVhciB0aGUgZW5kIG9mIHRoZSBibG9ncG9zdC4KClN0ZXAgdGhyb3VnaCB0aGUgZXhlY3V0aW9uIHRvIHNlZSB3aGF0J3MgaGFwcGVuaW5nOgoKIyMgRWxtIGltcGxlbWVudGF0aW9uCgpIb3BlZnVsbHkgeW91IG5vdGljZWQgdGhlIHBhcmFsbGVscyBiZXR3ZWVuIHRoZSB2aXN1YWwgaW50ZXJwcmV0YXRpb24gYW5kIHRoZSBmbG93Y2hhcnQncyByZWN1cnNpdmUgZGVzY2VudCBkb3duIHRoZSBzdGFjayBmcmFtZXMuCgpFYWNoIFByYXR0IHBhcnNlciBpcyBhYmxlIHRvIGhhbmRsZSBhIHNpbmdsZSBwcmVjZWRlbmNlIGxldmVsIGFuZCBkZWxlZ2F0ZSB0aGUgaGlnaGVyIGxldmVscyB0byBjaGlsZCBQcmF0dCBwYXJzZXJzLCB3aGlsZSByZWZ1c2luZyB0byBkbyBhbnl0aGluZyBmb3IgbG93ZXIgbGV2ZWxzLgoKV2VsbCwgbGV0J3MgZm9ybWFsaXplIHdoYXQgd2UganVzdCB3ZW50IHRocm91Z2ghCgpGaXJzdCwgbGV0J3MgZGVmaW5lIHRoZSB0eXBlcyB3ZSdsbCB3b3JrIHdpdGguCgpgYGBlbG0KdHlwZSBUb2tlbgogICAgPSBUTnVtIEludAogICAgfCBUT3AgQmlub3AKCnR5cGUgQmlub3AKICAgID0gQWRkCiAgICB8IFN1YgogICAgfCBNdWwKICAgIHwgRGl2CiAgICB8IFBvdwoKdHlwZSBFeHByCiAgICA9IE51bSBJbnQKICAgIHwgT3AgRXhwciBCaW5vcCBFeHByCmBgYAoKT3VyIHRva2VuIGxpc3QgYW5kIG9wZXJhdG9yIHByZWNlZGVuY2UgdGFibGU6CgpgYGBlbG0KZXhhbXBsZVRva2VucyA6IExpc3QgVG9rZW4KZXhhbXBsZVRva2VucyA9CiAgICBbIFROdW0gMQogICAgLCBUT3AgQWRkCiAgICAsIFROdW0gMgogICAgLCBUT3AgU3ViCiAgICAsIFROdW0gMwogICAgLCBUT3AgTXVsCiAgICAsIFROdW0gNAogICAgLCBUT3AgQWRkCiAgICAsIFROdW0gNQogICAgLCBUT3AgRGl2CiAgICAsIFROdW0gNgogICAgLCBUT3AgUG93CiAgICAsIFROdW0gNwogICAgLCBUT3AgU3ViCiAgICAsIFROdW0gOAogICAgLCBUT3AgTXVsCiAgICAsIFROdW0gOQogICAgXQoKcHJlY2VkZW5jZSA6IEJpbm9wIC0+IEludApwcmVjZWRlbmNlIGJpbm9wID0KICAgIGNhc2UgYmlub3Agb2YKICAgICAgICBBZGQgLT4gMQogICAgICAgIFN1YiAtPiAxCiAgICAgICAgTXVsIC0+IDIKICAgICAgICBEaXYgLT4gMgogICAgICAgIFBvdyAtPiAzCmBgYAoKQW5kIG5vdywgdGhlIGZ1biBiZWdpbnMuCgpgYGBlbG0KcGFyc2UgOiBMaXN0IFRva2VuIC0+IE1heWJlIEV4cHIKcGFyc2UgdG9rZW5zID0KICAgIGNhc2UgcHJhdHQgMCB0b2tlbnMgb2YKICAgICAgICBKdXN0ICggZXhwciwgdG9rZW5zQWZ0ZXJFeHByICkgLT4gSnVzdCBleHByCiAgICAgICAgTm90aGluZyAtPiBOb3RoaW5nCmBgYAoKVGhlIHRvcC1sZXZlbCBwYXJzZXIgY2FsbHMgYHByYXR0IDBgIGFuZCB0aGVuIHRocm93cyBhd2F5IHRoZSB0b2tlbnMgaXQgcmV0dXJucyAob25seSBrZWVwcyB0aGUgcGFyc2VkIGV4cHJlc3Npb24pLgoKV2UnbGwgZ2V0IHNvbWUgcHJlbGltaW5hcmllcyBvdXQgb2YgdGhlIHdheToKCmBgYGVsbQpwcmVmaXggOiBMaXN0IFRva2VuIC0+IE1heWJlIChFeHByLCBMaXN0IFRva2VuKQpwcmVmaXggdG9rZW5zID0KICAgIGNhc2UgdG9rZW5zIG9mCiAgICAgICAgW10gICAgICAgICAgICAgICAtPiBOb3RoaW5nCiAgICAgICAgKFROdW0gbikgOjogcmVzdCAtPiBKdXN0ICggTnVtIG4sIHJlc3QgKQogICAgICAgIChUT3AgIF8pIDo6IF8gICAgLT4gTm90aGluZwpgYGAKCj4gTm90ZSB0aGF0IGluIGEgbW9yZSBhZHZhbmNlZCBsYW5ndWFnZSB5b3UnZCBwcm9iYWJseSBoYXZlIHByZWZpeCBvcGVyYXRpb25zIGxpa2UgbmVnYXRpb24gKGAtNWApIG9yIGV4cGxpY2l0IGdyb3VwaW5nIHZpYSBwYXJlbnRoZXNlcyAoYCg1KzMpYCkuIFdlJ2xsIHRhbGsgYWJvdXQgdGhlc2UgbmVhciB0aGUgZW5kIG9mIHRoZSBibG9ncG9zdC4KCmBgYGVsbQpwcmF0dCA6IEludCAtPiBMaXN0IFRva2VuIC0+IE1heWJlIChFeHByLCBMaXN0IFRva2VuKQpwcmF0dCBwcmVjTGltaXQgdG9rZW5zID0KICAgIC0tIEZpcnN0IHBhcnNlIGEgcHJlZml4IGV4cHJlc3Npb24KICAgIGNhc2UgcHJlZml4IHRva2VucyBvZgogICAgICAgIE5vdGhpbmcgLT4gTm90aGluZwoKICAgICAgICBKdXN0ICggbGVmdCwgdG9rZW5zQWZ0ZXJQcmVmaXggKSAtPgogICAgICAgICAgICBwcmF0dExvb3AgcHJlY0xpbWl0IGxlZnQgdG9rZW5zQWZ0ZXJQcmVmaXgKCgpwcmF0dExvb3AgOiBJbnQgLT4gRXhwciAtPiBMaXN0IFRva2VuIC0+IE1heWJlIChFeHByLCBMaXN0IFRva2VuKQpwcmF0dExvb3AgcHJlY0xpbWl0IGxlZnQgdG9rZW5zQWZ0ZXJMZWZ0ID0KICAgIC0tIFRoZSBuZXh0IHRva2VuIGlzIGFuIG9wZXJhdG9yISBMZXQncyBmaW5kIGl0cyBwcmVjZWRlbmNlLgogICAgY2FzZSB0b2tlbnNBZnRlckxlZnQgb2YKICAgICAgICAtLSBPcGVyYXRvciEKICAgICAgICAoVE9wIG9wKSA6OiB0b2tlbnNBZnRlck9wIC0+CiAgICAgICAgICAgIGxldAogICAgICAgICAgICAgICAgb3BQcmVjIDogSW50CiAgICAgICAgICAgICAgICBvcFByZWMgPSBwcmVjZWRlbmNlIG9wCiAgICAgICAgICAgIGluCiAgICAgICAgICAgIC0tIE5vdywgYXJlIHdlIGFsbG93ZWQgdG8gcGFyc2UgdGhlIG5leHQgZXhwcmVzc2lvbgogICAgICAgICAgICAtLSBvciBpcyBpdCBvdXRzaWRlIHRoZSBsaW1pdD8KICAgICAgICAgICAgaWYgb3BQcmVjID4gcHJlY0xpbWl0IHRoZW4KICAgICAgICAgICAgICAgIC0tIFdlIGNhbiBwYXJzZSBpdCEgU3Bhd24gYSBjaGlsZCBQcmF0dCBwYXJzZXIuCiAgICAgICAgICAgICAgICBjYXNlIHByYXR0IG9wUHJlYyB0b2tlbnNBZnRlck9wIG9mCiAgICAgICAgICAgICAgICAgICAgLS0gV2hhdGV2ZXIgdGhlIGNoaWxkIFByYXR0IHBhcnNlciBkaWQsCiAgICAgICAgICAgICAgICAgICAgLS0gd2UgdGFrZSBpdCBhbmQgY29tYmluZSBpdCB3aXRoIG91ciBgbGVmdGAuCiAgICAgICAgICAgICAgICAgICAgSnVzdCAoIHJpZ2h0LCB0b2tlbnNBZnRlckNoaWxkICkgLT4KICAgICAgICAgICAgICAgICAgICAgICAgbGV0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMZWZ0IDogRXhwcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVmdCA9IE9wIG9wIGxlZnQgcmlnaHQKICAgICAgICAgICAgICAgICAgICAgICAgaW4KICAgICAgICAgICAgICAgICAgICAgICAgLS0gVGhlcmUgbWlnaHQgYmUgbW9yZSBvbiBvdXIgbGV2ZWwKICAgICAgICAgICAgICAgICAgICAgICAgLS0gKGxpa2UgaW4gMSsyLTMpLCBzbyBsZXQncyBsb29wLgogICAgICAgICAgICAgICAgICAgICAgICBwcmF0dExvb3AKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWNMaW1pdAogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVmdAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zQWZ0ZXJDaGlsZAoKICAgICAgICAgICAgICAgICAgICAtLSBBbiBlcnJvciwgcHJvcGFnYXRlIGl0LgogICAgICAgICAgICAgICAgICAgIE5vdGhpbmcgLT4gTm90aGluZwoKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgLS0gV2Ugc2hvdWxkbid0IHBhcnNlIHRoaXMgb3AuCiAgICAgICAgICAgICAgICAtLSBSZXR1cm4gd2hhdCB3ZSBoYXZlLgogICAgICAgICAgICAgICAgLS0gKE5vdGUgb3VyIHRva2VuIGxpc3QgcG9pbnRzIGF0IHRoZSBvcCwKICAgICAgICAgICAgICAgIC0tIG5vdCBhdCB0aGUgdG9rZW4gYWZ0ZXIuKQogICAgICAgICAgICAgICAgSnVzdCAoIGxlZnQsIHRva2Vuc0FmdGVyTGVmdCApCgogICAgICAgIC0tIEVpdGhlciB3ZSByYW4gb3V0IG9mIHRva2VucyBvciBmb3VuZCBzb21ldGhpbmcKICAgICAgICAtLSB0aGF0J3Mgbm90IGFuIG9wZXJhdG9yLiBMZXQncyByZXR1cm4gd2hhdCB3ZSBoYXZlLgogICAgICAgIF8gLT4gSnVzdCAoIGxlZnQsIHRva2Vuc0FmdGVyTGVmdCApCgpgYGAKCkFuZCB0aGF0J3MgYWxsIQoKUnVubmluZyB0aGlzLS0tZWl0aGVyIGluIHRoZSBgZWxtIHJlcGxgIG9yIGluIHRoZSBicm93c2VyIHdpdGggc29tZXRoaW5nIGxpa2U6CgpgYGBlbG0KbW9kdWxlIE1haW4gZXhwb3NpbmcgKG1haW4pCgppbXBvcnQgSHRtbAoKbWFpbiA9CiAgICBwYXJzZSBleGFtcGxlVG9rZW5zCiAgICAgICAgfD4gRGVidWcudG9TdHJpbmcKICAgICAgICB8PiBIdG1sLnRleHQKYGBgCgotLS13aWxsIHJlc3VsdCBpbjoKCmBgYGVsbQpKdXN0IChPcCAoT3AgKE9wIChPcCAoTnVtIDEpIEFkZCAoTnVtIDIpKQogICAgICAgICAgICAgICAgIFN1YgogICAgICAgICAgICAgICAgIChPcCAoTnVtIDMpIE11bCAoTnVtIDQpKSkKICAgICAgICAgICAgIEFkZAogICAgICAgICAgICAgKE9wIChOdW0gNSkKICAgICAgICAgICAgICAgICBEaXYKICAgICAgICAgICAgICAgICAoT3AgKE51bSA2KSBQb3cgKE51bSA3KSkpKQogICAgICAgICBTdWIKICAgICAgICAgKE9wIChOdW0gOCkgTXVsIChOdW0gOSkpKQpgYGAKCmFzIHlvdSBjYW4gc2VlIGluIFt0aGUgRWxsaWUgd2l0aCB0aGUgZnVsbCBzb3VyY2VdKGh0dHBzOi8vZWxsaWUtYXBwLmNvbS9uZktCeHBLSjVwdmExKS4KClRoaXMgY2FuIHdpdGggc29tZSBlbGJvdyBncmVhc2UgYmUgdHJhbnNsYXRlZCBpbnRvOgoKYGBgZWxtCigoKCgxICsgMikgLSAoMyAqIDQpKSArICg1IC8gKDYgXiA3KSkpIC0gKDggKiA5KSkKYGBgCgphbmQgaWYgeW91IHJlbW92ZSBwYXJlbnRoZXNlcyBhcm91bmQgcGx1c2VzIGFuZCBtaW51c2VzLCB5b3UnbGwgZ2V0IG91ciB3YW50ZWQgcmVzdWx0OgoKYGBgZWxtCjEgKyAyIC0gKDMgKiA0KSArICg1IC8gKDYgXiA3KSkgLSAoOCAqIDkpCmBgYAoKUGFyc2luZyBzdWNjZXNzZnVsIQoKIyMgTG9vc2UgdGhyZWFkcwoKVGhlIGFib3ZlIGlsbHVzdHJhdGVzIHRoZSBjb3JlIGlkZWEgUHJhdHQgcGFyc2VycyBvbiBsZWZ0LWFzc29jaWF0aXZlIGJpbmFyeSBvcGVyYXRvcnMsIGJ1dCB0aGF0IGlzbid0IGVub3VnaCBmb3IgcmVhbC13b3JsZCBsYW5ndWFnZXMuIFRoZXJlIGFyZSBhIGZldyB1bmFuc3dlcmVkIHF1ZXN0aW9ucy4gTGV0J3MgYW5zd2VyIHRoZW06CgojIyMgUmlnaHQtYXNzb2NpYXRpdml0eQoKV2hhdCBhYm91dCByaWdodC1hc3NvY2lhdGl2aXR5PyBgXmAgaXMgcmlnaHQtYXNzb2NpYXRpdmUsIG1lYW5pbmcgYDJeM140YCBzaG91bGQgcGFyc2UgaW50byBgMl4oM140KWAuCgpUaGFua2Z1bGx5IHRoaXMgaXMgc2ltcGxlIHRvIHNvbHZlOiBlYWNoIG9wZXJhdG9yIHdpbGwgbm93IGhhdmUgYW4gYGlzUmlnaHRBc3NvY2lhdGl2ZWAgYm9vbGVhbiBhc3NvY2lhdGVkIHdpdGggaXQgaW4gYWRkaXRpb24gdG8gdGhlIHByZWNlZGVuY2UgbGV2ZWwuCgpXaGVuIHRoZSBgcHJhdHRgIGZ1bmN0aW9uIGdldHMgdGhhdCBib29sZWFuLCBpdCB3aWxsIGNhbGN1bGF0ZSB0aGUgcHJlY2VkZW5jZSB0aGlzIHdheToKCmBgYGVsbQpvcFByZWMgOiBJbnQKb3BQcmVjID0gcHJlY2VkZW5jZSBvcAoKZmluYWxQcmVjIDogSW50CmZpbmFsUHJlYyA9CiAgICBpZiBpc1JpZ2h0QXNzb2NpYXRpdmUgb3AgdGhlbgogICAgICAgIG9wUHJlYyAtIDEKICAgIGVsc2UKICAgICAgICBvcFByZWMKYGBgCgpUaGVuIHlvdSBuZWVkIHRvIHVzZSBgb3BQcmVjYCBmb3IgdGhlIGNvbmRpdGlvbiBhbmQgYGZpbmFsUHJlY2AgZm9yIHRoZSByZWN1cnNpdmUgY2FsbDoKCmBgYGVsbQppZiBvcFByZWMgPiBwcmVjTGltaXQgdGhlbgogICAgY2FzZSBwcmF0dCBmaW5hbFByZWMgdG9rZW5zQWZ0ZXJPcCBvZgogICAgICAgIC4uLgpgYGAKCkFuZCB0aGF0J3MgaXQhCgpIZXJlJ3MgYSBydW5uYWJsZSBleGFtcGxlIHdpdGggcmlnaHQgYXNzb2NpYXRpdml0eSwgcGFyc2luZyBgMV4yXjMrNGAgaW50byBgKDFeKDJeMykpKzRgOiBbRWxsaWVdKGh0dHBzOi8vZWxsaWUtYXBwLmNvbS9uZzVHN0I4Z0xLc2ExKS4KCiMjIyBNb3JlIGNvbXBsZXggcHJlZml4IGV4cHJlc3Npb25zCgpJbiBvdXIgZXhhbXBsZSB3ZSBvbmx5IGhhZCBudW1iZXJzIGFzIHRoZSBwcmVmaXggZXhwcmVzc2lvbnMuIFdoYXQgaWYgd2Ugd2FudGVkIG5lZ2F0aW9uIGFuZCBwYXJlbnRoZXNlcz8KCkxldCdzIGFkZCBhIGZldyBuZXcgdG9rZW5zIHRvIGlsbHVzdHJhdGU6CgpgYGBlbG0KdHlwZSBUb2tlbgogICAgPSBUTnVtIEludAogICAgfCBUT3AgQmlub3AKICAgIHwgVExlZnRQYXJlbiAgLS0gbmV3CiAgICB8IFRSaWdodFBhcmVuIC0tIG5ldwpgYGAKCldlJ2xsIHJldXNlIGBUT3AgU3ViYCBmb3IgbmVnYXRpb247IG5vcm1hbGx5IHlvdSdkIGhhdmUgdG9rZW5zIGxpa2UgYE1pbnVzYCBhbmQgYFBsdXNgIHJhdGhlciB0aGFuIGFzc2lnbmluZyB0aGVtIG1lYW5pbmcgZHVyaW5nIGxleGluZy4KClRoaXMgaXMgaG93IHRoZSBuZXcgYHByZWZpeGAgcGFyc2VyIHdvdWxkIGxvb2s6CgpgYGBlbG0KcHJlZml4IDogTGlzdCBUb2tlbiAtPiBNYXliZSAoRXhwciwgTGlzdCBUb2tlbikKcHJlZml4IHRva2VucyA9CiAgICBjYXNlIHRva2VucyBvZgogICAgICAgIFtdIC0+IE5vdGhpbmcKICAgICAgICAoVE51bSBuKSA6OiByZXN0IC0+IEp1c3QgKCBOdW0gbiwgcmVzdCApCgogICAgICAgIC0tIG5lZ2F0aW9uLCBjb25zdW1lcyB0d28gdG9rZW5zCiAgICAgICAgKFRPcCBTdWIpIDo6IChUTnVtIG4pIDo6IHJlc3QgLT4KICAgICAgICAgICAgSnVzdCAoIE51bSAobmVnYXRlIG4pLCByZXN0ICkKCiAgICAgICAgLS0gbGVmdCBwYXJlbjogY29uc3VtZXMgJygnLCBhbiBleHByZXNzaW9uLCAnKScKICAgICAgICBUTGVmdFBhcmVuIDo6IHJlc3QgLT4gZ3JvdXBlZEV4cHIgcmVzdAoKICAgICAgICAtLSByaWdodCBwYXJlbjogZG9lc24ndCBtYWtlIHNlbnNlIG9uIGl0cyBvd24KICAgICAgICBUUmlnaHRQYXJlbiA6OiBfIC0+IE5vdGhpbmcKICAgICAgICAoVE9wICBfKSA6OiBfIC0+IE5vdGhpbmcKCmdyb3VwZWRFeHByIDogTGlzdCBUb2tlbiAtPiBNYXliZSAoRXhwciwgTGlzdCBUb2tlbikKZ3JvdXBlZEV4cHIgdG9rZW5zID0KICAgIC0tIEhhcyBjb25zdW1lZCBUTGVmdFBhcmVuIGFscmVhZHkKICAgIGNhc2UgcHJhdHQgMCB0b2tlbnMgb2YKICAgICAgICBOb3RoaW5nIC0+IE5vdGhpbmcKICAgICAgICBKdXN0IChleHByLCB0b2tlbnNBZnRlckV4cHIpIC0+CiAgICAgICAgICAgIGNhc2UgdG9rZW5zQWZ0ZXJFeHByIG9mCiAgICAgICAgICAgICAgICAtLSBBIGNsb3NpbmcgcGFyZW4gbXVzdCBmb2xsb3cKICAgICAgICAgICAgICAgIFRSaWdodFBhcmVuIDo6IHJlc3QgLT4gSnVzdCAoZXhwciwgcmVzdCkKCiAgICAgICAgICAgICAgICAtLSBVbmJhbGFuY2VkIHBhcmVucyEKICAgICAgICAgICAgICAgIF8gLT4gTm90aGluZwpgYGAKCiMjIyBQb3N0Zml4IGV4cHJlc3Npb25zCgpIb3cgdG8gbWFrZSBQcmF0dCBwYXJzZXJzIHN1cHBvcnQgcG9zdGZpeCBvcGVyYXRvcnMsIGxpa2UgYGkrK2Agb3IgYDUhYD8KClRoZXNlIGFyZSBhIHNwZWNpYWwgY2FzZSBvZiBpbmZpeCBvcGVyYXRvcnM6CgpQb3N0Zml4IGV4cHJlc3Npb25zIG5lZWQgdGhlIGBwcmVmaXhgIGV4cHJlc3Npb24gcGFyc2VkIGFuZCB0aGUgb3BlcmF0b3IgY29uc3VtZWQsIGJ1dCB0aGV5IGRvbid0IG5lZWQgdG8gY29uc3VtZSBhbnkgcmlnaHQgcGFydC4gVGh1cyB0aGVyZSB3b3VsZCBiZSBvbmUgbGVzcyBgcHJhdHRgIGNhbGwgZm9yIHRoZSByaWdodC1oYW5kIHNpZGUuCgpQb3N0Zml4IGV4cHJlc3Npb25zIGFyZSBhZG1pdHRlZGx5IHdoZXJlIEkgc2ltcGxpZmllZCBteSBleHBsYW5hdGlvbnMgdG9vIG11Y2guIFRoZSBQcmF0dCBwYXJzZXIgcmVhbGx5IGNhcmVzIGFib3V0IHR3byBjbGFzc2VzIG9mIG9wZXJhdG9yczogcHJlZml4LCBhbmQgYW55dGhpbmcgZWxzZS4KCkluIHRoZSBhYm92ZSBFbG0gY29kZSBJJ3ZlIGJha2VkIHRoZSBhc3N1bXB0aW9uIHdlJ2xsIG9ubHkgZGVhbCBwcmVmaXggYW5kIGluZml4IChiaW5hcnkpLCBpbnRvIHRoZSBgcHJhdHRgIGZ1bmN0aW9uIGl0c2VsZi4gSW4gcmVhbGl0eSBlYWNoIG9wZXJhdG9yIHRva2VuIHdvdWxkIGhhdmUgYSBwYXJzZXIgYXNzb2NpYXRlZCB3aXRoIGl0IHRoYXQgZGVhbHMgd2l0aCB3aGF0ZXZlcidzIF9hZnRlcl8gdGhlIG9wZXJhdG9yLCBhbmQgdGhlIGBwcmF0dGAgZnVuY3Rpb24gd291bGQgY2FsbCB0aGF0LgoKYGBgZWxtCnstfApFeGFtcGxlOiA1KzMKClRva2VuIGV4cGVjdGF0aW9uczoKCiAgICBleHByIG9wIGV4cHIKICAgIF5eXl5eXl4gYWxyZWFkeSBwYXJzZWQKLX0KYmluYXJ5T3AgOiBFeHByIC0+IEJpbm9wIC0+IEludCAtPiBMaXN0IFRva2VuIC0+IE1heWJlIChFeHByLCBMaXN0IFRva2VuKQpiaW5hcnlPcCBsZWZ0IG9wIHByZWNlZGVuY2UgdG9rZW5zQWZ0ZXJPcCA9CiAgICAtLSB3aGF0IHdlIGhhZCBiZWZvcmUgaW4gYHByYXR0YCwganVzdCBleHRyYWN0ZWQgaW50byBpdHMgb3duIGZ1bmN0aW9uCiAgICBjYXNlIHByYXR0IHByZWNlZGVuY2UgdG9rZW5zQWZ0ZXJPcCBvZgogICAgICAgIE5vdGhpbmcgLT4gTm90aGluZwogICAgICAgIEp1c3QgKHJpZ2h0LCB0b2tlbnNBZnRlclJpZ2h0KSAtPgogICAgICAgICAgICBKdXN0IChPcCBsZWZ0IG9wIHJpZ2h0LCB0b2tlbnNBZnRlclJpZ2h0KQpgYGAKCndoaWNoIHRoZW4gZ2l2ZXMgdXMgdGhlIGZyZWVkb20gdG8gd3JpdGUgcG9zdGZpeCBwYXJzZXJzLiBXaXRoIHNvbWUgaGFuZHdhdmluZyB0aGV5IGNvdWxkIGxvb2sgbGlrZToKCmBgYGVsbQp7LXwKRXhhbXBsZTogNSEKClRva2VuIGV4cGVjdGF0aW9uczoKCiAgICBleHByIEJhbmcKICAgIF5eXl5eXl5eXiBhbHJlYWR5IHBhcnNlZAotfQpwb3N0Zml4QmFuZyA6IEV4cHIgLT4gQmlub3AgLT4gTGlzdCBUb2tlbiAtPiBNYXliZSAoRXhwciwgTGlzdCBUb2tlbikKcG9zdGZpeEJhbmcgbGVmdCBvcCB0b2tlbnNBZnRlck9wID0KICAgIC0tIFdlJ3JlIGd1YXJhbnRlZWQgdG8gaGF2ZSBwYXJzZWQgdGhlIGAhYCBhbHJlYWR5CiAgICAtLSBOb3RoaW5nIHRvIGRvIGhlcmUhCiAgICBKdXN0IChVbmFyeU9wIEZhY3RvcmlhbCBsZWZ0LCB0b2tlbnNBZnRlck9wKQpgYGAKCiMjIENvbmNsdXNpb24KClByYXR0IHBhcnNlcnMgYXJlIG5pY2UgaW4gdGhhdCB0aGV5IGxldCB5b3UgZGVmaW5lIGEgdGFibGUgb2Ygb3BlcmF0b3JzIGFuZCB0aGVpciBwcmVjZWRlbmNlIGxldmVscywgd2hpY2ggdGhleSB0aGVuIHdvcmsgdGhyb3VnaDogdGhlIHRyYXZlcnNhbCBpdHNlbGYgaXMgYWJzdHJhY3RlZCBhd2F5LgoKUHJhdHQgcGFyc2VycyBfY2FuXyBiZSBzaHJvdWRlZCBpbiBteXN0ZXJ5IChwYXJ0aWN1bGFybHkgaWYgeW91IGVuY291bnRlciB0ZXJtcyBsaWtlIGBudWRgIGFuZCBgbGVkYCB3aGlsZSByZWFkaW5nIGFib3V0IHRoZW0gb3IgdXNpbmcgYSBsaWJyYXJ5IHRoYXQgZGlkbid0IGNhcmUgdG8gZmluZCBiZXR0ZXIgbmFtZXMpLgoKV2l0aCB0aGF0IGluIG1pbmQgSSBob3BlIEkgaGF2ZSBkZW15c3RpZmllZCB0aGlzIHRlY2huaXF1ZSBhIGxpdHRsZSBiaXQgYW5kIG1hZGUgeW91IGNvbnNpZGVyIHVzaW5nIG9yIHdyaXRpbmcgb25lLiBMaWZlJ3MgdG9vIHNob3J0IHRvIGRlYWwgd2l0aCBvcGVyYXRvciBwcmVjZWRlbmNlIGluIGFuIGFkLWhvYyB3YXkhCgQBNC9pbWFnZXMvYXV0aG9ycy9tYXJ0aW4uanBnAAAeTWFydGluIEphbmljemVrAAxtYXJ0aW4CDnR3aXR0ZXI4aHR0cHM6Ly90d2l0dGVyLmNvbS9KYW5pY3plawE2L2ltYWdlcy9hdXRob3JzL2RlZmF1bHQucG5n26IKIyBIaSB0aGVyZSEKCiMjIEknbSBQcm9mZXNzb3IgRnJhbmtsaW4gRnJpc2J5LiAKClBsZWFzZWQgdG8gbWFrZSB5b3VyIGFjcXVhaW50YW5jZS4gV2UnbGwgYmUgc3BlbmRpbmcgc29tZSB0aW1lIHRvZ2V0aGVyLCBhcyBJJ20gc3VwcG9zZWQgdG8gdGVhY2ggeW91IGEgYml0IGFib3V0IGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcuCgpJIHdvbid0IGFzc3VtZSB0aGF0IHlvdSBoYXZlIGFueSBwcmV2aW91cyBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGtub3dsZWRnZSwgYmVjYXVzZSB3ZSBib3RoIGtub3cgd2hhdCBoYXBwZW5zIHdoZW4geW91IGFzc3VtZS4gCgpJIHdpbGwsIGhvd2V2ZXIsIGV4cGVjdCB5b3UgdG8gaGF2ZSBydW4gaW50byBzb21lIG9mIHRoZSBfdW5mYXZvcmFibGUgc2l0dWF0aW9uc18gdGhhdCBhcmlzZSB3aGVuIHdvcmtpbmcgd2l0aCAqKm11dGFibGUgc3RhdGUqKiwgKip1bnJlc3RyaWN0ZWQgc2lkZSBlZmZlY3RzKiosIGFuZCAqKnVucHJpbmNpcGxlZCBkZXNpZ24qKi4gCgpOb3cgdGhhdCB3ZSd2ZSBiZWVuIHByb3Blcmx5IGludHJvZHVjZWQsIGxldCdzIGdldCBvbiB3aXRoIGl0LgoBJkVhc3QgRWxtIFVuaXZlcnNpdHkeRnJhbmtsaW4gRnJpc2J5AUZQcm9mZXNzb3Igb2YgRnVuY3Rpb25hbCBQcm9ncmFtbWluZw5kZWZhdWx0DAplbWFpbDhwcm9mZXNzb3IuZnJpc2J5QGV4YW1wbGUuY29tDnR3aXR0ZXI2aHR0cHM6Ly90d2l0dGVyLmNvbS9Ud2l0dGVyEGZhY2Vib29rMGh0dHBzOi8vd3d3LmZhY2Vib29rLmNvbRBsaW5rZWRpbjBodHRwczovL3d3dy5saW5rZWRpbi5jb20OeW91dHViZSZodHRwczovL3lvdXR1YmUuY29tDGdpdGh1YiRodHRwczovL2dpdGh1Yi5jb20BAZpQcmF0dCBwYXJzZXJzIGFyZSBhIGJlYXV0aWZ1bCB3YXkgb2Ygc29sdmluZyB0aGUgb3BlcmF0b3IgcHJlY2VkZW5jZSBwcm9ibGVtLgAmGnByYXR0LXBhcnNlcnMCAP0WiyAANERlbXlzdGlmeWluZyBQcmF0dCBQYXJzZXJzAQIBNi9pbWFnZXMvYXV0aG9ycy9kZWZhdWx0LnBuZ9uiCiMgSGkgdGhlcmUhCgojIyBJJ20gUHJvZmVzc29yIEZyYW5rbGluIEZyaXNieS4gCgpQbGVhc2VkIHRvIG1ha2UgeW91ciBhY3F1YWludGFuY2UuIFdlJ2xsIGJlIHNwZW5kaW5nIHNvbWUgdGltZSB0b2dldGhlciwgYXMgSSdtIHN1cHBvc2VkIHRvIHRlYWNoIHlvdSBhIGJpdCBhYm91dCBmdW5jdGlvbmFsIHByb2dyYW1taW5nLgoKSSB3b24ndCBhc3N1bWUgdGhhdCB5b3UgaGF2ZSBhbnkgcHJldmlvdXMgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBrbm93bGVkZ2UsIGJlY2F1c2Ugd2UgYm90aCBrbm93IHdoYXQgaGFwcGVucyB3aGVuIHlvdSBhc3N1bWUuIAoKSSB3aWxsLCBob3dldmVyLCBleHBlY3QgeW91IHRvIGhhdmUgcnVuIGludG8gc29tZSBvZiB0aGUgX3VuZmF2b3JhYmxlIHNpdHVhdGlvbnNfIHRoYXQgYXJpc2Ugd2hlbiB3b3JraW5nIHdpdGggKiptdXRhYmxlIHN0YXRlKiosICoqdW5yZXN0cmljdGVkIHNpZGUgZWZmZWN0cyoqLCBhbmQgKip1bnByaW5jaXBsZWQgZGVzaWduKiouIAoKTm93IHRoYXQgd2UndmUgYmVlbiBwcm9wZXJseSBpbnRyb2R1Y2VkLCBsZXQncyBnZXQgb24gd2l0aCBpdC4KASZFYXN0IEVsbSBVbml2ZXJzaXR5HkZyYW5rbGluIEZyaXNieQFGUHJvZmVzc29yIG9mIEZ1bmN0aW9uYWwgUHJvZ3JhbW1pbmcOZGVmYXVsdAwKZW1haWw4cHJvZmVzc29yLmZyaXNieUBleGFtcGxlLmNvbQ50d2l0dGVyNmh0dHBzOi8vdHdpdHRlci5jb20vVHdpdHRlchBmYWNlYm9vazBodHRwczovL3d3dy5mYWNlYm9vay5jb20QbGlua2VkaW4waHR0cHM6Ly93d3cubGlua2VkaW4uY29tDnlvdXR1YmUmaHR0cHM6Ly95b3V0dWJlLmNvbQxnaXRodWIkaHR0cHM6Ly9naXRodWIuY29tAQGCTGV0cyB0cnkgdG8gYnVpbGQgc29tZSBuaWNlIHNtYWxsIHRlbXBsYXRlIGZvciBlbG0tcGFnZXMgYmxvZ2dpbmcAAlIyMDIzLTA5LTA2LXNpbXBsZS1hbmQtbmljZS1lbG0tcGFnZXMtYmxvZwIA/RaLogYGZWxtEmVsbS1wYWdlcwhibG9nYlNpbXBsZSBhbmQgbmljZSBibG9nZ2luZyB0ZW1wbGF0ZSBmb3IgZWxt4oCRcGFnZXMBAgE2L2ltYWdlcy9hdXRob3JzL2RlZmF1bHQucG5n26IKIyBIaSB0aGVyZSEKCiMjIEknbSBQcm9mZXNzb3IgRnJhbmtsaW4gRnJpc2J5LiAKClBsZWFzZWQgdG8gbWFrZSB5b3VyIGFjcXVhaW50YW5jZS4gV2UnbGwgYmUgc3BlbmRpbmcgc29tZSB0aW1lIHRvZ2V0aGVyLCBhcyBJJ20gc3VwcG9zZWQgdG8gdGVhY2ggeW91IGEgYml0IGFib3V0IGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcuCgpJIHdvbid0IGFzc3VtZSB0aGF0IHlvdSBoYXZlIGFueSBwcmV2aW91cyBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGtub3dsZWRnZSwgYmVjYXVzZSB3ZSBib3RoIGtub3cgd2hhdCBoYXBwZW5zIHdoZW4geW91IGFzc3VtZS4gCgpJIHdpbGwsIGhvd2V2ZXIsIGV4cGVjdCB5b3UgdG8gaGF2ZSBydW4gaW50byBzb21lIG9mIHRoZSBfdW5mYXZvcmFibGUgc2l0dWF0aW9uc18gdGhhdCBhcmlzZSB3aGVuIHdvcmtpbmcgd2l0aCAqKm11dGFibGUgc3RhdGUqKiwgKip1bnJlc3RyaWN0ZWQgc2lkZSBlZmZlY3RzKiosIGFuZCAqKnVucHJpbmNpcGxlZCBkZXNpZ24qKi4gCgpOb3cgdGhhdCB3ZSd2ZSBiZWVuIHByb3Blcmx5IGludHJvZHVjZWQsIGxldCdzIGdldCBvbiB3aXRoIGl0LgoBJkVhc3QgRWxtIFVuaXZlcnNpdHkeRnJhbmtsaW4gRnJpc2J5AUZQcm9mZXNzb3Igb2YgRnVuY3Rpb25hbCBQcm9ncmFtbWluZw5kZWZhdWx0DAplbWFpbDhwcm9mZXNzb3IuZnJpc2J5QGV4YW1wbGUuY29tDnR3aXR0ZXI2aHR0cHM6Ly90d2l0dGVyLmNvbS9Ud2l0dGVyEGZhY2Vib29rMGh0dHBzOi8vd3d3LmZhY2Vib29rLmNvbRBsaW5rZWRpbjBodHRwczovL3d3dy5saW5rZWRpbi5jb20OeW91dHViZSZodHRwczovL3lvdXR1YmUuY29tDGdpdGh1YiRodHRwczovL2dpdGh1Yi5jb20BAdhkRWxtIGlzIGEgZnVuY3Rpb25hbCBsYW5ndWFnZSB0aGF0IGNvbXBpbGVzIHRvIEphdmFTY3JpcHQuIEl0IGhlbHBzIHlvdSBtYWtlIHdlYnNpdGVzIGFuZCB3ZWIgYXBwcy4gSXQgaGFzIGEgc3Ryb25nIGVtcGhhc2lzIG9uIHNpbXBsaWNpdHkgYW5kIHF1YWxpdHkgdG9vbGluZy4AAkIyMDE5LTEwLTAxLWFuLWludHJvZHVjdGlvbi10by1lbG0CAP0WgGoCBmVsbSxBbiBJbnRyb2R1Y3Rpb24gdG8gRWxtAA==</script>
    <script type="module" crossorigin src="/assets/index-C9SU9G8M.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-CM8pqJ-r.css">
  </head>
  <body>
    <div data-url="" display="none"></div>
    <div class="absolute z-20 top-0 inset-x-0 flex justify-center overflow-hidden pointer-events-none"><div class="w-[108rem] flex-none flex justify-end"><picture><source srcset="/media/docs@30.8b9a76a2.avif" type="image/avif"><img class="w-[71.75rem] flex-none max-w-none dark:hidden" alt="" decoding="async" src="/media/docs@tinypng.d9e4dcdc.png"></picture><picture><source srcset="/media/docs-dark@30.1a9f8cbf.avif" type="image/avif"><img class="w-[90rem] flex-none max-w-none hidden dark:block" alt="" decoding="async" src="/media/docs-dark@tinypng.1bbe175e.png"></picture></div></div>
<div class="mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0"><div class="flex h-screen flex-col justify-between font-sans"><header class="flex items-center justify-between py-10"><div><a aria-label="elm blog" href="/"><div class="flex items-center justify-between"><div class="mr-1 text-primary-600 dark:text-primary-500"><svg height="80" viewBox="0 0 700 351" width="80"><g fill="currentColor" fill-rule="evenodd"><path d="M529.5 169 700 0H359zM349.7 349l79.7-79H270zM266.2 86.5l79 79.7V6.8zM352 180h168l-82 82H270zM175.77 176.5l84.85-84.85 84.85 84.85-84.85 84.85zM353.03 173.3l166.87-1.4L354.44 6.42zM170.5 182 341 351H0z"></path></g></svg></div><div class="h-6 text-2xl font-semibold dark:text-white">elm blog</div></div></a></div><nav class="flex items-center leading-5 space-x-4 sm:space-x-6"><a class="hidden sm:block font-medium text-gray-900 dark:text-gray-100 hover:underline decoration-primary-500" elm-pages:prefetch="" href="/tech-blog">Tech Blog</a><a class="hidden sm:block font-medium text-gray-900 dark:text-gray-100 hover:underline decoration-primary-500" elm-pages:prefetch="" href="/life-blog">Life Blog</a><a class="hidden sm:block font-medium text-gray-900 dark:text-gray-100 hover:underline decoration-primary-500" elm-pages:prefetch="" href="/tags">Tags</a><a class="hidden sm:block font-medium text-gray-900 dark:text-gray-100 hover:underline decoration-primary-500" elm-pages:prefetch="" href="/about">About</a><button class="sm:hidden" aria-label="Toggle Menu"><svg class="text-gray-900 dark:text-gray-100 h-8 w-8" fill="currentColor" viewBox="0 0 20 20"><path clip-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" fill-rule="evenodd"></path></svg></button><div class="fixed left-0 top-0 z-10 h-full w-full transform opacity-95 dark:opacity-[0.98] bg-white duration-300 ease-in-out dark:bg-gray-950 translate-x-full"><div class="flex justify-end"><button class="mr-8 mt-11 h-8 w-8" aria-label="Toggle Menu"><svg class="text-gray-900 dark:text-gray-100" fill="currentColor" viewBox="0 0 20 20"><path clip-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" fill-rule="evenodd"></path></svg></button></div><div class="fixed mt-8 h-full"><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" elm-pages:prefetch="" href="/">Home</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" elm-pages:prefetch="" href="/tech-blog">Tech Blog</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" elm-pages:prefetch="" href="/life-blog">Life Blog</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" elm-pages:prefetch="" href="/tags">Tags</a></div><div class="px-12 py-4"><a class="text-2xl font-bold tracking-widest text-gray-900 dark:text-gray-100" elm-pages:prefetch="" href="/about">About</a></div></div></div></nav></header><main class="w-full mb-auto"><div><div class="max-w-[65ch] m-auto space-y-1 xl:text-xl dark:border-gray-700"><div><h1 class="mt-8 pb-4 font-bold text-3xl md:text-5xl text-gray-900 dark:text-gray-100">Demystifying Pratt Parsers</h1><dl class="max-w-[65ch] py-4 xl:pb-8 xl:pt-12"><dt class="sr-only">Authors</dt><dd class="border-l-4 border-primary-500 pl-4 flex"><div class="flex -space-x-2"><img class="h-12 w-12 rounded-full hidden sm:block" style="color:transparent;" alt="avatar" data-nimg="1" decoding="async" height="38" loading="lazy" src="/images/authors/martin.jpg" width="38"><img class="h-12 w-12 rounded-full hidden sm:block" style="color:transparent;" alt="avatar" data-nimg="1" decoding="async" height="38" loading="lazy" src="/images/authors/default.png" width="38"></div><div class="flex flex-col justify-around items-start sm:pl-4"><span class="text-lg font-bold text-black dark:text-white">Martin Janiczek, Franklin Frisby</span><div class="flex space-x-4 text-base"><dl><dt class="sr-only">Published on</dt><dd class="leading-6 text-gray-500 dark:text-gray-400"><time datetime="2023-07-03">3. Jul 2023</time></dd></dl><span>19 min reading time</span></div></div></dd></dl></div></div><div class="mx-auto prose-p:my-4 prose lg:prose-xl dark:prose-invert"><p class="font-bold">Pratt parsers are a beautiful way of solving the operator precedence problem.</p></div><article class="mx-auto prose lg:prose-xl dark:prose-invert"><h2 id="tl-dr"><a class="not-prose group " aria-label="Permalink for TL;DR" href="#tl-dr"><span class="group-hover:underline decoration-primary-500">TL;DR</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h2><p>Here&#039;s the algorithm for <code>pratt(precLimit)</code>:</p><p><a href="/images/pratt-parsers/algorithm.png"><img alt="Pratt parser algorithm" src="/content/tech-blog/pratt-parsers/assets/algorithm.png"></a></p><p><a href="https://ellie-app.com/nfKBxpKJ5pva1">Here&#039;s a minimal commented Pratt parser example in Elm.</a></p><h2 id="table-of-contents"><a class="not-prose group " aria-label="Permalink for Table of contents" href="#table-of-contents"><span class="group-hover:underline decoration-primary-500">Table of contents</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h2><ul><li><a href="#introduction">Introduction</a></li><li><a href="#bob-nystroms-article">Bob Nystrom&#039;s article</a></li><li><a href="#overview">Overview</a></li><li><a href="#visual-intuition">Visual intuition</a></li><li><a href="#walk-through-example">Walk-through example</a></li><li><a href="#elm-implementation">Elm implementation</a></li><li><a href="#loose-threads">Loose threads</a></li><li><a href="#conclusion">Conclusion</a></li></ul><h2 id="introduction"><a class="not-prose group " aria-label="Permalink for Introduction" href="#introduction"><span class="group-hover:underline decoration-primary-500">Introduction</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h2><p>Pratt parsers are a beautiful way of solving the operator precedence problem:</p><p>How can an expression like <code>1+2-3*4+5/6^7-8*9</code> be parsed to meet the expectations of your <a href="https://en.wikipedia.org/wiki/Order_of_operations#Mnemonics">PEMDAS</a>-trained brain? Where do you put the parentheses? <em>What goes first?</em></p><p>The underlying problem is the frequent ambiguity in combinations of operators. For example, how should the expression <code>1+2*3</code> be interpreted?</p><p>There are two options, each leading to a different value.</p><p><img alt="Ambiguity of multiple binary operators" src="/content/tech-blog/pratt-parsers/assets/ambiguity.png"></p><p>There are <a href="https://en.wikipedia.org/wiki/Operator-precedence_parser">a few algorithms</a> to solve this problem. Among them, my favorite is the <a href="https://en.wikipedia.org/wiki/Operator-precedence_parser#Pratt_parsing">Pratt parser</a>---the most intuitive and declarative solution in my view.</p><p>Pratt parsers are an algorithm that takes your tokens (<code>[1, +, 2, *, 3]</code>) and a table like:</p><table><thead><tr><th>Operator</th><th>Precedence</th></tr></thead><tbody><tr><td>+</td><td>1</td></tr><tr><td>-</td><td>1</td></tr><tr><td>*</td><td>2</td></tr><tr><td>/</td><td>2</td></tr><tr><td>^</td><td>3</td></tr></tbody></table><p>and spit out the correctly parenthesized/nested expression (<code>1 + (2 * 3)</code>). So nice!</p><p>But <em>how do they work?</em></p><h2 id="bob-nystrom-s-article"><a class="not-prose group " aria-label="Permalink for Bob Nystrom's article" href="#bob-nystrom-s-article"><span class="group-hover:underline decoration-primary-500">Bob Nystrom&#039;s article</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h2><p>The original paper <em>&quot;Top Down Operator Precedence&quot;</em> (<a href="https://web.archive.org/web/20151223215421/http://hall.org.ua/halls/wizzard/pdf/Vaughan.Pratt.TDOP.pdf">PDF</a> or this beautiful <a href="https://tdop.github.io">HTML rendering</a>) by Vaughan Pratt has a lot of theory, theorems and proofs, is somewhat philosophical at times, and spends quite some time dealing with problems of its time (1973).</p><p>Of course, as an academic paper it has a different target audience, so let&#039;s not hold that against it. It also makes sense for it (introducing a new idea) to discuss motivation. But that makes it all the harder to find the important parts in the paper.</p><p>And I suspect that&#039;s the reason people write summaries. You don&#039;t need the 1973 motivation, you just need to <em>solve the operator precedence problem!</em></p><p>The best summary and explanation of Pratt parsers I know of (at least for the audience of an amateur programming language designer in 2023) is written by <a href="https://twitter.com/munificentbob">Bob Nystrom</a> in his blogpost <a href="https://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/"><em>&quot;Pratt Parsers: Expression Parsing Made Easy&quot;</em></a>. You should definitely read it! (Along with other Bob&#039;s writings, like <a href="https://craftinginterpreters.com"><em>Crafting Interpreters</em></a>.)</p><p>The examples Bob gives are written in Java, and the <a href="https://github.com/munificent/bantam">full example implementation</a> is split across multiple small classes.</p><p>I feel that we can do a bit better pedagogically---it can be tricky making sense of the idea when spread out like this, and it can also be challenging to port the idea from OOP to a FP language.</p><p>Not that you&#039;d be unable to make sense of the Java code, but I see pedagogical value in trying to simplify <em>even more.</em></p><p>So, that&#039;s my motivation for writing this article! Let&#039;s try and see how would a more minimal and concise implementation look in <a href="https://elm-lang.org/">Elm</a>!</p><blockquote><p>Spoiler: <a href="https://ellie-app.com/nfKBxpKJ5pva1"><em>here it is.</em></a></p></blockquote><p>The language is pure, immutable, has no escape hatches, has no spooky action at a distance (eg. default arguments or exceptions) and no obscure features (except for perhaps <a href="https://en.wikipedia.org/wiki/Tagged_union">sum types</a>, but even those are thankfully getting more and more common in other languages).</p><p>Hence, if you can write it in Elm, you can likely write it in anything else.</p><h2 id="overview"><a class="not-prose group " aria-label="Permalink for Overview" href="#overview"><span class="group-hover:underline decoration-primary-500">Overview</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h2><p>The idea of Pratt parsing is very simple:</p><p>Each operator has <em>a precedence</em> (a number) associated with it. Larger number means higher priority, eg. multiplication has higher priority than addition.</p><p>The Pratt parser holds <em>a precedence limit</em>. It can be thought of as: &quot;You&#039;re only allowed to parse operators with precedence <em>higher</em> than this number.&quot;</p><blockquote><p>The precedence limit of the top-level expression is 0. Thus you could define your <code>expr(tokens)</code> parser as <code>pratt(0,tokens)</code>.</p></blockquote><p>The Pratt parser first parses a prefix expression (the <em>left</em> part of the <code>Op(left, op, right)</code>), then starts a loop.</p><p>In the loop it looks at the next token. If there are no tokens left, or if it&#039;s not a known binary operator, or if it <em>is</em> but its precedence is equal or lower than the limit, the parser ends and returns the left expression, alongside an information about what token to look at next (= whatever&#039;s immediately after the left expression).</p><p>If the token is a known binary operator with <em>higher</em> precedence than the limit held by the Pratt parser, the parser spawns another Pratt parser with a limit equal to the operator&#039;s precedence.</p><p>Whatever that inner Pratt parser returns (the <em>right</em> part of the op), the outer one combines into <code>Op(left, op, right)</code> which becomes the <em>left</em> for the next loop.</p><p>That way the Pratt parser manages to consume all operations above its limit. A Pratt parser consuming <code>*</code> and <code>/</code> will also consume <code>^</code> into a (parenthesized) child via the nested <code>pratt(...)</code> calls, but will never touch <code>+</code> and <code>-</code>.</p><p>...Well, that was a mouthful. Here it is in the flowchart form again:</p><p><a href="/images/pratt-parsers/algorithm.png"><img alt="Pratt parser algorithm" src="/content/tech-blog/pratt-parsers/assets/algorithm.png"></a></p><p>I wouldn&#039;t blame you if it didn&#039;t click right away! To aid understanding, let&#039;s examine what the algorithm does from a few different perspectives: visually, then reading through an execution trace, and then finally the code itself.</p><h2 id="visual-intuition"><a class="not-prose group " aria-label="Permalink for Visual intuition" href="#visual-intuition"><span class="group-hover:underline decoration-primary-500">Visual intuition</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h2><p>Here&#039;s the expression we&#039;re interested in parsing:</p><p><img alt="Original expression" src="/content/tech-blog/pratt-parsers/assets/source.png"></p><p>If we focus on <em>adding parentheses</em> (instead of tree creation), we want to end up with something similar to the following:</p><p><img alt="Expression with added parentheses" src="/content/tech-blog/pratt-parsers/assets/parenthesized.png"></p><p>Let&#039;s assign the precedence values to the operators:</p><table><thead><tr><th>Operator</th><th>Precedence</th></tr></thead><tbody><tr><td>+</td><td>1</td></tr><tr><td>-</td><td>1</td></tr><tr><td>*</td><td>2</td></tr><tr><td>/</td><td>2</td></tr><tr><td>^</td><td>3</td></tr></tbody></table><p>Now let&#039;s put operators on separate lines according to their precedence:</p><p><img alt="Separated" src="/content/tech-blog/pratt-parsers/assets/separated.png"></p><p>In order to get some visual intuition on this problem, we&#039;ll repeat a simple process on each level: given a region in a level above, we&#039;ll draw regions <em>between</em> the operators on our current level:</p><p><img alt="Process we'll follow" src="/content/tech-blog/pratt-parsers/assets/process.png"></p><p>At the very top (<code>p=0</code>) we&#039;ll start with one large region:</p><p><img alt="p=0" src="/content/tech-blog/pratt-parsers/assets/p0.png"></p><p>One level below (<code>p=1</code>), we split the region whenever we encounter an operator on our level---that is, <code>+</code> or <code>-</code>.</p><p><img alt="p=1" src="/content/tech-blog/pratt-parsers/assets/p1.png"></p><p>Continuing on to <code>p=2</code>, we&#039;ll split each blue region when we find <code>*</code> or <code>/</code>.</p><blockquote><p>To make the diagram less cluttered, we&#039;ll skip processing regions with single numbers, eg. here <code>1</code> and <code>2</code>.</p></blockquote><p><img alt="p=2" src="/content/tech-blog/pratt-parsers/assets/p2.png"></p><p>And then finally on level <code>p=3</code> we split the region containing the <code>^</code>.</p><p><img alt="p=3" src="/content/tech-blog/pratt-parsers/assets/p3.png"></p><p>By now perhaps you already see what&#039;s happening: <em>each blue region represents a set of parentheses!</em></p><p>Let&#039;s clean the diagram up a little before we show that off: parentheses with no operators inside aren&#039;t very helpful (eg. <code>(3)</code> vs <code>3</code>), so we&#039;ll remove the blue regions that only hold single numbers:</p><p><img alt="Cleaned up" src="/content/tech-blog/pratt-parsers/assets/cleanedup.png"></p><p>And now we can finally replace each beginning of a blue region with <code>(</code> and each end with <code>)</code>:</p><p><img alt="Converted" src="/content/tech-blog/pratt-parsers/assets/converted.png"></p><p>Merging each level into the one above, we end up with the parenthesized expression we wanted:</p><p><img alt="Merged" src="/content/tech-blog/pratt-parsers/assets/parenthesized.png"></p><p>What we have been doing visually, corresponds to the Pratt parser algorithm: the blue regions on level <code>p=n</code> are calls to the <code>pratt(n)</code> parser. (Except for the leftmost numbers of each block, which are handled by the <code>prefix</code> parser.)</p><p>Let&#039;s now walk through the algorithm on an example to see that. <em>(I swear there&#039;s going to be some code in this blogpost eventually.)</em></p><h2 id="walk-through-example"><a class="not-prose group " aria-label="Permalink for Walk-through example" href="#walk-through-example"><span class="group-hover:underline decoration-primary-500">Walk-through example</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h2><p>The source we&#039;re trying to parse is <code>1+2-3*4+5/6^7-8*9</code>.</p><p>It corresponds to a sequence of tokens:</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh4 elmsh-elm-gs">[</span> <span class="elmsh1 elmsh-elm-n">1</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh3 elmsh-elm-bs">+</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh1 elmsh-elm-n">2</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh3 elmsh-elm-bs">-</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh1 elmsh-elm-n">3</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh3 elmsh-elm-bs">*</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh1 elmsh-elm-n">4</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh3 elmsh-elm-bs">+</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh1 elmsh-elm-n">5</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh3 elmsh-elm-bs">/</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh1 elmsh-elm-n">6</span><span class="elmsh4 elmsh-elm-gs">,</span> ^<span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh1 elmsh-elm-n">7</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh3 elmsh-elm-bs">-</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh1 elmsh-elm-n">8</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh3 elmsh-elm-bs">*</span><span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh1 elmsh-elm-n">9</span> <span class="elmsh4 elmsh-elm-gs">]</span></div></code></pre></div><p>The precedences are as follows:</p><table><thead><tr><th>Operator</th><th>Precedence</th></tr></thead><tbody><tr><td>+</td><td>1</td></tr><tr><td>-</td><td>1</td></tr><tr><td>*</td><td>2</td></tr><tr><td>/</td><td>2</td></tr><tr><td>^</td><td>3</td></tr></tbody></table><blockquote><p>In this simplified example, there are no unary operators. We&#039;ll talk about those near the end of the blogpost.</p></blockquote><p>Step through the execution to see what&#039;s happening:</p><h2 id="elm-implementation"><a class="not-prose group " aria-label="Permalink for Elm implementation" href="#elm-implementation"><span class="group-hover:underline decoration-primary-500">Elm implementation</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h2><p>Hopefully you noticed the parallels between the visual interpretation and the flowchart&#039;s recursive descent down the stack frames.</p><p>Each Pratt parser is able to handle a single precedence level and delegate the higher levels to child Pratt parsers, while refusing to do anything for lower levels.</p><p>Well, let&#039;s formalize what we just went through!</p><p>First, let&#039;s define the types we&#039;ll work with.</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh3 elmsh-elm-k">type</span> <span class="elmsh6 elmsh-elm-c">Token</span>
</div><div class="elmsh-line" data-elmsh-lc="2">    <span class="elmsh3 elmsh-elm-bs">=</span> <span class="elmsh6 elmsh-elm-c">TNum</span> <span class="elmsh6 elmsh-elm-c">Int</span>
</div><div class="elmsh-line" data-elmsh-lc="3">    <span class="elmsh3 elmsh-elm-bs">|</span> <span class="elmsh6 elmsh-elm-c">TOp</span> <span class="elmsh6 elmsh-elm-c">Binop</span>
</div><div class="elmsh-line" data-elmsh-lc="4">
</div><div class="elmsh-line" data-elmsh-lc="5"><span class="elmsh3 elmsh-elm-k">type</span> <span class="elmsh6 elmsh-elm-c">Binop</span>
</div><div class="elmsh-line" data-elmsh-lc="6">    <span class="elmsh3 elmsh-elm-bs">=</span> <span class="elmsh6 elmsh-elm-c">Add</span>
</div><div class="elmsh-line" data-elmsh-lc="7">    <span class="elmsh3 elmsh-elm-bs">|</span> <span class="elmsh6 elmsh-elm-c">Sub</span>
</div><div class="elmsh-line" data-elmsh-lc="8">    <span class="elmsh3 elmsh-elm-bs">|</span> <span class="elmsh6 elmsh-elm-c">Mul</span>
</div><div class="elmsh-line" data-elmsh-lc="9">    <span class="elmsh3 elmsh-elm-bs">|</span> <span class="elmsh6 elmsh-elm-c">Div</span>
</div><div class="elmsh-line" data-elmsh-lc="10">    <span class="elmsh3 elmsh-elm-bs">|</span> <span class="elmsh6 elmsh-elm-c">Pow</span>
</div><div class="elmsh-line" data-elmsh-lc="11">
</div><div class="elmsh-line" data-elmsh-lc="12"><span class="elmsh3 elmsh-elm-k">type</span> <span class="elmsh6 elmsh-elm-c">Expr</span>
</div><div class="elmsh-line" data-elmsh-lc="13">    <span class="elmsh3 elmsh-elm-bs">=</span> <span class="elmsh6 elmsh-elm-c">Num</span> <span class="elmsh6 elmsh-elm-c">Int</span>
</div><div class="elmsh-line" data-elmsh-lc="14">    <span class="elmsh3 elmsh-elm-bs">|</span> <span class="elmsh6 elmsh-elm-c">Op</span> <span class="elmsh6 elmsh-elm-c">Expr</span> <span class="elmsh6 elmsh-elm-c">Binop</span> <span class="elmsh6 elmsh-elm-c">Expr</span></div></code></pre></div><p>Our token list and operator precedence table:</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh5 elmsh-elm-f">exampleTokens</span> <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span>
</div><div class="elmsh-line" data-elmsh-lc="2"><span class="elmsh5 elmsh-elm-f">exampleTokens</span> <span class="elmsh3 elmsh-elm-bs">=</span>
</div><div class="elmsh-line" data-elmsh-lc="3">    <span class="elmsh4 elmsh-elm-gs">[</span> <span class="elmsh6 elmsh-elm-c">TNum</span> <span class="elmsh1 elmsh-elm-n">1</span>
</div><div class="elmsh-line" data-elmsh-lc="4">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TOp</span> <span class="elmsh6 elmsh-elm-c">Add</span>
</div><div class="elmsh-line" data-elmsh-lc="5">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TNum</span> <span class="elmsh1 elmsh-elm-n">2</span>
</div><div class="elmsh-line" data-elmsh-lc="6">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TOp</span> <span class="elmsh6 elmsh-elm-c">Sub</span>
</div><div class="elmsh-line" data-elmsh-lc="7">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TNum</span> <span class="elmsh1 elmsh-elm-n">3</span>
</div><div class="elmsh-line" data-elmsh-lc="8">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TOp</span> <span class="elmsh6 elmsh-elm-c">Mul</span>
</div><div class="elmsh-line" data-elmsh-lc="9">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TNum</span> <span class="elmsh1 elmsh-elm-n">4</span>
</div><div class="elmsh-line" data-elmsh-lc="10">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TOp</span> <span class="elmsh6 elmsh-elm-c">Add</span>
</div><div class="elmsh-line" data-elmsh-lc="11">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TNum</span> <span class="elmsh1 elmsh-elm-n">5</span>
</div><div class="elmsh-line" data-elmsh-lc="12">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TOp</span> <span class="elmsh6 elmsh-elm-c">Div</span>
</div><div class="elmsh-line" data-elmsh-lc="13">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TNum</span> <span class="elmsh1 elmsh-elm-n">6</span>
</div><div class="elmsh-line" data-elmsh-lc="14">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TOp</span> <span class="elmsh6 elmsh-elm-c">Pow</span>
</div><div class="elmsh-line" data-elmsh-lc="15">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TNum</span> <span class="elmsh1 elmsh-elm-n">7</span>
</div><div class="elmsh-line" data-elmsh-lc="16">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TOp</span> <span class="elmsh6 elmsh-elm-c">Sub</span>
</div><div class="elmsh-line" data-elmsh-lc="17">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TNum</span> <span class="elmsh1 elmsh-elm-n">8</span>
</div><div class="elmsh-line" data-elmsh-lc="18">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TOp</span> <span class="elmsh6 elmsh-elm-c">Mul</span>
</div><div class="elmsh-line" data-elmsh-lc="19">    <span class="elmsh4 elmsh-elm-gs">,</span> <span class="elmsh6 elmsh-elm-c">TNum</span> <span class="elmsh1 elmsh-elm-n">9</span>
</div><div class="elmsh-line" data-elmsh-lc="20">    <span class="elmsh4 elmsh-elm-gs">]</span>
</div><div class="elmsh-line" data-elmsh-lc="21">
</div><div class="elmsh-line" data-elmsh-lc="22"><span class="elmsh5 elmsh-elm-f">precedence</span> <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh4 elmsh-elm-ts">Binop</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Int</span>
</div><div class="elmsh-line" data-elmsh-lc="23"><span class="elmsh5 elmsh-elm-f">precedence</span> binop <span class="elmsh3 elmsh-elm-bs">=</span>
</div><div class="elmsh-line" data-elmsh-lc="24">    <span class="elmsh3 elmsh-elm-k">case</span> binop <span class="elmsh3 elmsh-elm-k">of</span>
</div><div class="elmsh-line" data-elmsh-lc="25">        <span class="elmsh6 elmsh-elm-c">Add</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh1 elmsh-elm-n">1</span>
</div><div class="elmsh-line" data-elmsh-lc="26">        <span class="elmsh6 elmsh-elm-c">Sub</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh1 elmsh-elm-n">1</span>
</div><div class="elmsh-line" data-elmsh-lc="27">        <span class="elmsh6 elmsh-elm-c">Mul</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh1 elmsh-elm-n">2</span>
</div><div class="elmsh-line" data-elmsh-lc="28">        <span class="elmsh6 elmsh-elm-c">Div</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh1 elmsh-elm-n">2</span>
</div><div class="elmsh-line" data-elmsh-lc="29">        <span class="elmsh6 elmsh-elm-c">Pow</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh1 elmsh-elm-n">3</span></div></code></pre></div><p>And now, the fun begins.</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh5 elmsh-elm-f">parse</span> <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Maybe</span> <span class="elmsh4 elmsh-elm-ts">Expr</span>
</div><div class="elmsh-line" data-elmsh-lc="2"><span class="elmsh5 elmsh-elm-f">parse</span> tokens <span class="elmsh3 elmsh-elm-bs">=</span>
</div><div class="elmsh-line" data-elmsh-lc="3">    <span class="elmsh3 elmsh-elm-k">case</span> pratt <span class="elmsh1 elmsh-elm-n">0</span> tokens <span class="elmsh3 elmsh-elm-k">of</span>
</div><div class="elmsh-line" data-elmsh-lc="4">        <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span> expr<span class="elmsh4 elmsh-elm-gs">,</span> tokensAfterExpr <span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Just</span> expr
</div><div class="elmsh-line" data-elmsh-lc="5">        <span class="elmsh6 elmsh-elm-c">Nothing</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Nothing</span></div></code></pre></div><p>The top-level parser calls <code>pratt 0</code> and then throws away the tokens it returns (only keeps the parsed expression).</p><p>We&#039;ll get some preliminaries out of the way:</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh5 elmsh-elm-f">prefix</span> <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Maybe</span> (<span class="elmsh4 elmsh-elm-ts">Expr</span>, <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span>)
</div><div class="elmsh-line" data-elmsh-lc="2"><span class="elmsh5 elmsh-elm-f">prefix</span> tokens <span class="elmsh3 elmsh-elm-bs">=</span>
</div><div class="elmsh-line" data-elmsh-lc="3">    <span class="elmsh3 elmsh-elm-k">case</span> tokens <span class="elmsh3 elmsh-elm-k">of</span>
</div><div class="elmsh-line" data-elmsh-lc="4">        <span class="elmsh4 elmsh-elm-gs">[]</span>               <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Nothing</span>
</div><div class="elmsh-line" data-elmsh-lc="5">        <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">TNum</span> n<span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">::</span> rest <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span> <span class="elmsh6 elmsh-elm-c">Num</span> n<span class="elmsh4 elmsh-elm-gs">,</span> rest <span class="elmsh3 elmsh-elm-bs">)</span>
</div><div class="elmsh-line" data-elmsh-lc="6">        <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">TOp</span>  _<span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">::</span> _    <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Nothing</span></div></code></pre></div><blockquote><p>Note that in a more advanced language you&#039;d probably have prefix operations like negation (<code>-5</code>) or explicit grouping via parentheses (<code>(5+3)</code>). We&#039;ll talk about these near the end of the blogpost.</p></blockquote><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh5 elmsh-elm-f">pratt</span> <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh4 elmsh-elm-ts">Int</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Maybe</span> (<span class="elmsh4 elmsh-elm-ts">Expr</span>, <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span>)
</div><div class="elmsh-line" data-elmsh-lc="2"><span class="elmsh5 elmsh-elm-f">pratt</span> precLimit tokens <span class="elmsh3 elmsh-elm-bs">=</span>
</div><div class="elmsh-line" data-elmsh-lc="3">    <span class="elmsh-comm">-- First parse a prefix expression</span>
</div><div class="elmsh-line" data-elmsh-lc="4">    <span class="elmsh3 elmsh-elm-k">case</span> prefix tokens <span class="elmsh3 elmsh-elm-k">of</span>
</div><div class="elmsh-line" data-elmsh-lc="5">        <span class="elmsh6 elmsh-elm-c">Nothing</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Nothing</span>
</div><div class="elmsh-line" data-elmsh-lc="6">
</div><div class="elmsh-line" data-elmsh-lc="7">        <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span> left<span class="elmsh4 elmsh-elm-gs">,</span> tokensAfterPrefix <span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span>
</div><div class="elmsh-line" data-elmsh-lc="8">            prattLoop precLimit left tokensAfterPrefix
</div><div class="elmsh-line" data-elmsh-lc="9">
</div><div class="elmsh-line" data-elmsh-lc="10">
</div><div class="elmsh-line" data-elmsh-lc="11"><span class="elmsh5 elmsh-elm-f">prattLoop</span> <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh4 elmsh-elm-ts">Int</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Expr</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Maybe</span> (<span class="elmsh4 elmsh-elm-ts">Expr</span>, <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span>)
</div><div class="elmsh-line" data-elmsh-lc="12"><span class="elmsh5 elmsh-elm-f">prattLoop</span> precLimit left tokensAfterLeft <span class="elmsh3 elmsh-elm-bs">=</span>
</div><div class="elmsh-line" data-elmsh-lc="13">    <span class="elmsh-comm">-- The next token is an operator! Let&#039;s find its precedence.</span>
</div><div class="elmsh-line" data-elmsh-lc="14">    <span class="elmsh3 elmsh-elm-k">case</span> tokensAfterLeft <span class="elmsh3 elmsh-elm-k">of</span>
</div><div class="elmsh-line" data-elmsh-lc="15">        <span class="elmsh-comm">-- Operator!</span>
</div><div class="elmsh-line" data-elmsh-lc="16">        <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">TOp</span> op<span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">::</span> tokensAfterOp <span class="elmsh3 elmsh-elm-bs">-&gt;</span>
</div><div class="elmsh-line" data-elmsh-lc="17">            <span class="elmsh3 elmsh-elm-k">let</span>
</div><div class="elmsh-line" data-elmsh-lc="18">                opPrec <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh6 elmsh-elm-c">Int</span>
</div><div class="elmsh-line" data-elmsh-lc="19">                opPrec <span class="elmsh3 elmsh-elm-bs">=</span> precedence op
</div><div class="elmsh-line" data-elmsh-lc="20">            <span class="elmsh3 elmsh-elm-k">in</span>
</div><div class="elmsh-line" data-elmsh-lc="21">            <span class="elmsh-comm">-- Now, are we allowed to parse the next expression</span>
</div><div class="elmsh-line" data-elmsh-lc="22">            <span class="elmsh-comm">-- or is it outside the limit?</span>
</div><div class="elmsh-line" data-elmsh-lc="23">            <span class="elmsh3 elmsh-elm-k">if</span> opPrec <span class="elmsh3 elmsh-elm-bs">&gt;</span> precLimit <span class="elmsh3 elmsh-elm-k">then</span>
</div><div class="elmsh-line" data-elmsh-lc="24">                <span class="elmsh-comm">-- We can parse it! Spawn a child Pratt parser.</span>
</div><div class="elmsh-line" data-elmsh-lc="25">                <span class="elmsh3 elmsh-elm-k">case</span> pratt opPrec tokensAfterOp <span class="elmsh3 elmsh-elm-k">of</span>
</div><div class="elmsh-line" data-elmsh-lc="26">                    <span class="elmsh-comm">-- Whatever the child Pratt parser did,</span>
</div><div class="elmsh-line" data-elmsh-lc="27">                    <span class="elmsh-comm">-- we take it and combine it with our `left`.</span>
</div><div class="elmsh-line" data-elmsh-lc="28">                    <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span> right<span class="elmsh4 elmsh-elm-gs">,</span> tokensAfterChild <span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span>
</div><div class="elmsh-line" data-elmsh-lc="29">                        <span class="elmsh3 elmsh-elm-k">let</span>
</div><div class="elmsh-line" data-elmsh-lc="30">                            newLeft <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh6 elmsh-elm-c">Expr</span>
</div><div class="elmsh-line" data-elmsh-lc="31">                            newLeft <span class="elmsh3 elmsh-elm-bs">=</span> <span class="elmsh6 elmsh-elm-c">Op</span> op left right
</div><div class="elmsh-line" data-elmsh-lc="32">                        <span class="elmsh3 elmsh-elm-k">in</span>
</div><div class="elmsh-line" data-elmsh-lc="33">                        <span class="elmsh-comm">-- There might be more on our level</span>
</div><div class="elmsh-line" data-elmsh-lc="34">                        <span class="elmsh-comm">-- (like in 1+2-3), so let&#039;s loop.</span>
</div><div class="elmsh-line" data-elmsh-lc="35">                        prattLoop
</div><div class="elmsh-line" data-elmsh-lc="36">                            precLimit
</div><div class="elmsh-line" data-elmsh-lc="37">                            newLeft
</div><div class="elmsh-line" data-elmsh-lc="38">                            tokensAfterChild
</div><div class="elmsh-line" data-elmsh-lc="39">
</div><div class="elmsh-line" data-elmsh-lc="40">                    <span class="elmsh-comm">-- An error, propagate it.</span>
</div><div class="elmsh-line" data-elmsh-lc="41">                    <span class="elmsh6 elmsh-elm-c">Nothing</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Nothing</span>
</div><div class="elmsh-line" data-elmsh-lc="42">
</div><div class="elmsh-line" data-elmsh-lc="43">            <span class="elmsh3 elmsh-elm-k">else</span>
</div><div class="elmsh-line" data-elmsh-lc="44">                <span class="elmsh-comm">-- We shouldn&#039;t parse this op.</span>
</div><div class="elmsh-line" data-elmsh-lc="45">                <span class="elmsh-comm">-- Return what we have.</span>
</div><div class="elmsh-line" data-elmsh-lc="46">                <span class="elmsh-comm">-- (Note our token list points at the op,</span>
</div><div class="elmsh-line" data-elmsh-lc="47">                <span class="elmsh-comm">-- not at the token after.)</span>
</div><div class="elmsh-line" data-elmsh-lc="48">                <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span> left<span class="elmsh4 elmsh-elm-gs">,</span> tokensAfterLeft <span class="elmsh3 elmsh-elm-bs">)</span>
</div><div class="elmsh-line" data-elmsh-lc="49">
</div><div class="elmsh-line" data-elmsh-lc="50">        <span class="elmsh-comm">-- Either we ran out of tokens or found something</span>
</div><div class="elmsh-line" data-elmsh-lc="51">        <span class="elmsh-comm">-- that&#039;s not an operator. Let&#039;s return what we have.</span>
</div><div class="elmsh-line" data-elmsh-lc="52">        _ <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span> left<span class="elmsh4 elmsh-elm-gs">,</span> tokensAfterLeft <span class="elmsh3 elmsh-elm-bs">)</span>
</div><div class="elmsh-line" data-elmsh-lc="53"></div></code></pre></div><p>And that&#039;s all!</p><p>Running this---either in the <code>elm repl</code> or in the browser with something like:</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh3 elmsh-elm-k">module</span> Main <span class="elmsh3 elmsh-elm-k">exposing</span> (<span class="elmsh5 elmsh-elm-f">main</span>)
</div><div class="elmsh-line" data-elmsh-lc="2">
</div><div class="elmsh-line" data-elmsh-lc="3"><span class="elmsh3 elmsh-elm-k">import</span> Html
</div><div class="elmsh-line" data-elmsh-lc="4">
</div><div class="elmsh-line" data-elmsh-lc="5"><span class="elmsh5 elmsh-elm-f">main</span> <span class="elmsh3 elmsh-elm-bs">=</span>
</div><div class="elmsh-line" data-elmsh-lc="6">    parse exampleTokens
</div><div class="elmsh-line" data-elmsh-lc="7">        <span class="elmsh3 elmsh-elm-bs">|&gt;</span> <span class="elmsh6 elmsh-elm-c">Debug</span><span class="elmsh1 elmsh-elm-n">.</span>toString
</div><div class="elmsh-line" data-elmsh-lc="8">        <span class="elmsh3 elmsh-elm-bs">|&gt;</span> <span class="elmsh6 elmsh-elm-c">Html</span><span class="elmsh1 elmsh-elm-n">.</span>text</div></code></pre></div><p>---will result in:</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Op</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Op</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Op</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Op</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Num</span> <span class="elmsh1 elmsh-elm-n">1</span><span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh6 elmsh-elm-c">Add</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Num</span> <span class="elmsh1 elmsh-elm-n">2</span><span class="elmsh3 elmsh-elm-bs">))</span>
</div><div class="elmsh-line" data-elmsh-lc="2">                 <span class="elmsh6 elmsh-elm-c">Sub</span>
</div><div class="elmsh-line" data-elmsh-lc="3">                 <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Op</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Num</span> <span class="elmsh1 elmsh-elm-n">3</span><span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh6 elmsh-elm-c">Mul</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Num</span> <span class="elmsh1 elmsh-elm-n">4</span><span class="elmsh3 elmsh-elm-bs">)))</span>
</div><div class="elmsh-line" data-elmsh-lc="4">             <span class="elmsh6 elmsh-elm-c">Add</span>
</div><div class="elmsh-line" data-elmsh-lc="5">             <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Op</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Num</span> <span class="elmsh1 elmsh-elm-n">5</span><span class="elmsh3 elmsh-elm-bs">)</span>
</div><div class="elmsh-line" data-elmsh-lc="6">                 <span class="elmsh6 elmsh-elm-c">Div</span>
</div><div class="elmsh-line" data-elmsh-lc="7">                 <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Op</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Num</span> <span class="elmsh1 elmsh-elm-n">6</span><span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh6 elmsh-elm-c">Pow</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Num</span> <span class="elmsh1 elmsh-elm-n">7</span><span class="elmsh3 elmsh-elm-bs">))))</span>
</div><div class="elmsh-line" data-elmsh-lc="8">         <span class="elmsh6 elmsh-elm-c">Sub</span>
</div><div class="elmsh-line" data-elmsh-lc="9">         <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Op</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Num</span> <span class="elmsh1 elmsh-elm-n">8</span><span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh6 elmsh-elm-c">Mul</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Num</span> <span class="elmsh1 elmsh-elm-n">9</span><span class="elmsh3 elmsh-elm-bs">)))</span></div></code></pre></div><p>as you can see in <a href="https://ellie-app.com/nfKBxpKJ5pva1">the Ellie with the full source</a>.</p><p>This can with some elbow grease be translated into:</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh3 elmsh-elm-bs">((((</span><span class="elmsh1 elmsh-elm-n">1</span> <span class="elmsh3 elmsh-elm-bs">+</span> <span class="elmsh1 elmsh-elm-n">2</span><span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">-</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh1 elmsh-elm-n">3</span> <span class="elmsh3 elmsh-elm-bs">*</span> <span class="elmsh1 elmsh-elm-n">4</span><span class="elmsh3 elmsh-elm-bs">))</span> <span class="elmsh3 elmsh-elm-bs">+</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh1 elmsh-elm-n">5</span> <span class="elmsh3 elmsh-elm-bs">/</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh1 elmsh-elm-n">6</span> ^ <span class="elmsh1 elmsh-elm-n">7</span><span class="elmsh3 elmsh-elm-bs">)))</span> <span class="elmsh3 elmsh-elm-bs">-</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh1 elmsh-elm-n">8</span> <span class="elmsh3 elmsh-elm-bs">*</span> <span class="elmsh1 elmsh-elm-n">9</span><span class="elmsh3 elmsh-elm-bs">))</span></div></code></pre></div><p>and if you remove parentheses around pluses and minuses, you&#039;ll get our wanted result:</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh1 elmsh-elm-n">1</span> <span class="elmsh3 elmsh-elm-bs">+</span> <span class="elmsh1 elmsh-elm-n">2</span> <span class="elmsh3 elmsh-elm-bs">-</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh1 elmsh-elm-n">3</span> <span class="elmsh3 elmsh-elm-bs">*</span> <span class="elmsh1 elmsh-elm-n">4</span><span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">+</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh1 elmsh-elm-n">5</span> <span class="elmsh3 elmsh-elm-bs">/</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh1 elmsh-elm-n">6</span> ^ <span class="elmsh1 elmsh-elm-n">7</span><span class="elmsh3 elmsh-elm-bs">))</span> <span class="elmsh3 elmsh-elm-bs">-</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh1 elmsh-elm-n">8</span> <span class="elmsh3 elmsh-elm-bs">*</span> <span class="elmsh1 elmsh-elm-n">9</span><span class="elmsh3 elmsh-elm-bs">)</span></div></code></pre></div><p>Parsing successful!</p><h2 id="loose-threads"><a class="not-prose group " aria-label="Permalink for Loose threads" href="#loose-threads"><span class="group-hover:underline decoration-primary-500">Loose threads</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h2><p>The above illustrates the core idea Pratt parsers on left-associative binary operators, but that isn&#039;t enough for real-world languages. There are a few unanswered questions. Let&#039;s answer them:</p><h3 id="right-associativity"><a class="not-prose group " aria-label="Permalink for Right-associativity" href="#right-associativity"><span class="group-hover:underline decoration-primary-500">Right-associativity</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h3><p>What about right-associativity? <code>^</code> is right-associative, meaning <code>2^3^4</code> should parse into <code>2^(3^4)</code>.</p><p>Thankfully this is simple to solve: each operator will now have an <code>isRightAssociative</code> boolean associated with it in addition to the precedence level.</p><p>When the <code>pratt</code> function gets that boolean, it will calculate the precedence this way:</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh5 elmsh-elm-f">opPrec</span> <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh4 elmsh-elm-ts">Int</span>
</div><div class="elmsh-line" data-elmsh-lc="2"><span class="elmsh5 elmsh-elm-f">opPrec</span> <span class="elmsh3 elmsh-elm-bs">=</span> precedence op
</div><div class="elmsh-line" data-elmsh-lc="3">
</div><div class="elmsh-line" data-elmsh-lc="4"><span class="elmsh5 elmsh-elm-f">finalPrec</span> <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh4 elmsh-elm-ts">Int</span>
</div><div class="elmsh-line" data-elmsh-lc="5"><span class="elmsh5 elmsh-elm-f">finalPrec</span> <span class="elmsh3 elmsh-elm-bs">=</span>
</div><div class="elmsh-line" data-elmsh-lc="6">    <span class="elmsh3 elmsh-elm-k">if</span> isRightAssociative op <span class="elmsh3 elmsh-elm-k">then</span>
</div><div class="elmsh-line" data-elmsh-lc="7">        opPrec <span class="elmsh3 elmsh-elm-bs">-</span> <span class="elmsh1 elmsh-elm-n">1</span>
</div><div class="elmsh-line" data-elmsh-lc="8">    <span class="elmsh3 elmsh-elm-k">else</span>
</div><div class="elmsh-line" data-elmsh-lc="9">        opPrec</div></code></pre></div><p>Then you need to use <code>opPrec</code> for the condition and <code>finalPrec</code> for the recursive call:</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh3 elmsh-elm-k">if</span> opPrec <span class="elmsh3 elmsh-elm-bs">&gt;</span> precLimit <span class="elmsh3 elmsh-elm-k">then</span>
</div><div class="elmsh-line" data-elmsh-lc="2">    <span class="elmsh3 elmsh-elm-k">case</span> pratt finalPrec tokensAfterOp <span class="elmsh3 elmsh-elm-k">of</span>
</div><div class="elmsh-line" data-elmsh-lc="3">        <span class="elmsh1 elmsh-elm-n">...</span></div></code></pre></div><p>And that&#039;s it!</p><p>Here&#039;s a runnable example with right associativity, parsing <code>1^2^3+4</code> into <code>(1^(2^3))+4</code>: <a href="https://ellie-app.com/ng5G7B8gLKsa1">Ellie</a>.</p><h3 id="more-complex-prefix-expressions"><a class="not-prose group " aria-label="Permalink for More complex prefix expressions" href="#more-complex-prefix-expressions"><span class="group-hover:underline decoration-primary-500">More complex prefix expressions</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h3><p>In our example we only had numbers as the prefix expressions. What if we wanted negation and parentheses?</p><p>Let&#039;s add a few new tokens to illustrate:</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh3 elmsh-elm-k">type</span> <span class="elmsh6 elmsh-elm-c">Token</span>
</div><div class="elmsh-line" data-elmsh-lc="2">    <span class="elmsh3 elmsh-elm-bs">=</span> <span class="elmsh6 elmsh-elm-c">TNum</span> <span class="elmsh6 elmsh-elm-c">Int</span>
</div><div class="elmsh-line" data-elmsh-lc="3">    <span class="elmsh3 elmsh-elm-bs">|</span> <span class="elmsh6 elmsh-elm-c">TOp</span> <span class="elmsh6 elmsh-elm-c">Binop</span>
</div><div class="elmsh-line" data-elmsh-lc="4">    <span class="elmsh3 elmsh-elm-bs">|</span> <span class="elmsh6 elmsh-elm-c">TLeftParen</span>  <span class="elmsh-comm">-- new</span>
</div><div class="elmsh-line" data-elmsh-lc="5">    <span class="elmsh3 elmsh-elm-bs">|</span> <span class="elmsh6 elmsh-elm-c">TRightParen</span> <span class="elmsh-comm">-- new</span></div></code></pre></div><p>We&#039;ll reuse <code>TOp Sub</code> for negation; normally you&#039;d have tokens like <code>Minus</code> and <code>Plus</code> rather than assigning them meaning during lexing.</p><p>This is how the new <code>prefix</code> parser would look:</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh5 elmsh-elm-f">prefix</span> <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Maybe</span> (<span class="elmsh4 elmsh-elm-ts">Expr</span>, <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span>)
</div><div class="elmsh-line" data-elmsh-lc="2"><span class="elmsh5 elmsh-elm-f">prefix</span> tokens <span class="elmsh3 elmsh-elm-bs">=</span>
</div><div class="elmsh-line" data-elmsh-lc="3">    <span class="elmsh3 elmsh-elm-k">case</span> tokens <span class="elmsh3 elmsh-elm-k">of</span>
</div><div class="elmsh-line" data-elmsh-lc="4">        <span class="elmsh4 elmsh-elm-gs">[]</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Nothing</span>
</div><div class="elmsh-line" data-elmsh-lc="5">        <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">TNum</span> n<span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">::</span> rest <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span> <span class="elmsh6 elmsh-elm-c">Num</span> n<span class="elmsh4 elmsh-elm-gs">,</span> rest <span class="elmsh3 elmsh-elm-bs">)</span>
</div><div class="elmsh-line" data-elmsh-lc="6">
</div><div class="elmsh-line" data-elmsh-lc="7">        <span class="elmsh-comm">-- negation, consumes two tokens</span>
</div><div class="elmsh-line" data-elmsh-lc="8">        <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">TOp</span> <span class="elmsh6 elmsh-elm-c">Sub</span><span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">::</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">TNum</span> n<span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">::</span> rest <span class="elmsh3 elmsh-elm-bs">-&gt;</span>
</div><div class="elmsh-line" data-elmsh-lc="9">            <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span> <span class="elmsh6 elmsh-elm-c">Num</span> <span class="elmsh3 elmsh-elm-bs">(</span>negate n<span class="elmsh3 elmsh-elm-bs">)</span><span class="elmsh4 elmsh-elm-gs">,</span> rest <span class="elmsh3 elmsh-elm-bs">)</span>
</div><div class="elmsh-line" data-elmsh-lc="10">
</div><div class="elmsh-line" data-elmsh-lc="11">        <span class="elmsh-comm">-- left paren: consumes &#039;(&#039;, an expression, &#039;)&#039;</span>
</div><div class="elmsh-line" data-elmsh-lc="12">        <span class="elmsh6 elmsh-elm-c">TLeftParen</span> <span class="elmsh3 elmsh-elm-bs">::</span> rest <span class="elmsh3 elmsh-elm-bs">-&gt;</span> groupedExpr rest
</div><div class="elmsh-line" data-elmsh-lc="13">
</div><div class="elmsh-line" data-elmsh-lc="14">        <span class="elmsh-comm">-- right paren: doesn&#039;t make sense on its own</span>
</div><div class="elmsh-line" data-elmsh-lc="15">        <span class="elmsh6 elmsh-elm-c">TRightParen</span> <span class="elmsh3 elmsh-elm-bs">::</span> _ <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Nothing</span>
</div><div class="elmsh-line" data-elmsh-lc="16">        <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">TOp</span>  _<span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">::</span> _ <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Nothing</span>
</div><div class="elmsh-line" data-elmsh-lc="17">
</div><div class="elmsh-line" data-elmsh-lc="18"><span class="elmsh5 elmsh-elm-f">groupedExpr</span> <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Maybe</span> (<span class="elmsh4 elmsh-elm-ts">Expr</span>, <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span>)
</div><div class="elmsh-line" data-elmsh-lc="19"><span class="elmsh5 elmsh-elm-f">groupedExpr</span> tokens <span class="elmsh3 elmsh-elm-bs">=</span>
</div><div class="elmsh-line" data-elmsh-lc="20">    <span class="elmsh-comm">-- Has consumed TLeftParen already</span>
</div><div class="elmsh-line" data-elmsh-lc="21">    <span class="elmsh3 elmsh-elm-k">case</span> pratt <span class="elmsh1 elmsh-elm-n">0</span> tokens <span class="elmsh3 elmsh-elm-k">of</span>
</div><div class="elmsh-line" data-elmsh-lc="22">        <span class="elmsh6 elmsh-elm-c">Nothing</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Nothing</span>
</div><div class="elmsh-line" data-elmsh-lc="23">        <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span>expr<span class="elmsh4 elmsh-elm-gs">,</span> tokensAfterExpr<span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span>
</div><div class="elmsh-line" data-elmsh-lc="24">            <span class="elmsh3 elmsh-elm-k">case</span> tokensAfterExpr <span class="elmsh3 elmsh-elm-k">of</span>
</div><div class="elmsh-line" data-elmsh-lc="25">                <span class="elmsh-comm">-- A closing paren must follow</span>
</div><div class="elmsh-line" data-elmsh-lc="26">                <span class="elmsh6 elmsh-elm-c">TRightParen</span> <span class="elmsh3 elmsh-elm-bs">::</span> rest <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span>expr<span class="elmsh4 elmsh-elm-gs">,</span> rest<span class="elmsh3 elmsh-elm-bs">)</span>
</div><div class="elmsh-line" data-elmsh-lc="27">
</div><div class="elmsh-line" data-elmsh-lc="28">                <span class="elmsh-comm">-- Unbalanced parens!</span>
</div><div class="elmsh-line" data-elmsh-lc="29">                _ <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Nothing</span></div></code></pre></div><h3 id="postfix-expressions"><a class="not-prose group " aria-label="Permalink for Postfix expressions" href="#postfix-expressions"><span class="group-hover:underline decoration-primary-500">Postfix expressions</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h3><p>How to make Pratt parsers support postfix operators, like <code>i++</code> or <code>5!</code>?</p><p>These are a special case of infix operators:</p><p>Postfix expressions need the <code>prefix</code> expression parsed and the operator consumed, but they don&#039;t need to consume any right part. Thus there would be one less <code>pratt</code> call for the right-hand side.</p><p>Postfix expressions are admittedly where I simplified my explanations too much. The Pratt parser really cares about two classes of operators: prefix, and anything else.</p><p>In the above Elm code I&#039;ve baked the assumption we&#039;ll only deal prefix and infix (binary), into the <code>pratt</code> function itself. In reality each operator token would have a parser associated with it that deals with whatever&#039;s <em>after</em> the operator, and the <code>pratt</code> function would call that.</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh-comm">{-|</span>
</div><div class="elmsh-line" data-elmsh-lc="2"><span class="elmsh-comm">Example: 5+3</span>
</div><div class="elmsh-line" data-elmsh-lc="3">
</div><div class="elmsh-line" data-elmsh-lc="4"><span class="elmsh-comm">Token expectations:</span>
</div><div class="elmsh-line" data-elmsh-lc="5">
</div><div class="elmsh-line" data-elmsh-lc="6"><span class="elmsh-comm">    expr op expr</span>
</div><div class="elmsh-line" data-elmsh-lc="7"><span class="elmsh-comm">    ^^^^^^^ already parsed</span>
</div><div class="elmsh-line" data-elmsh-lc="8"><span class="elmsh-comm">-}</span>
</div><div class="elmsh-line" data-elmsh-lc="9"><span class="elmsh5 elmsh-elm-f">binaryOp</span> <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh4 elmsh-elm-ts">Expr</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Binop</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Int</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Maybe</span> (<span class="elmsh4 elmsh-elm-ts">Expr</span>, <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span>)
</div><div class="elmsh-line" data-elmsh-lc="10"><span class="elmsh5 elmsh-elm-f">binaryOp</span> left op precedence tokensAfterOp <span class="elmsh3 elmsh-elm-bs">=</span>
</div><div class="elmsh-line" data-elmsh-lc="11">    <span class="elmsh-comm">-- what we had before in `pratt`, just extracted into its own function</span>
</div><div class="elmsh-line" data-elmsh-lc="12">    <span class="elmsh3 elmsh-elm-k">case</span> pratt precedence tokensAfterOp <span class="elmsh3 elmsh-elm-k">of</span>
</div><div class="elmsh-line" data-elmsh-lc="13">        <span class="elmsh6 elmsh-elm-c">Nothing</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh6 elmsh-elm-c">Nothing</span>
</div><div class="elmsh-line" data-elmsh-lc="14">        <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span>right<span class="elmsh4 elmsh-elm-gs">,</span> tokensAfterRight<span class="elmsh3 elmsh-elm-bs">)</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span>
</div><div class="elmsh-line" data-elmsh-lc="15">            <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">Op</span> left op right<span class="elmsh4 elmsh-elm-gs">,</span> tokensAfterRight<span class="elmsh3 elmsh-elm-bs">)</span></div></code></pre></div><p>which then gives us the freedom to write postfix parsers. With some handwaving they could look like:</p><div class="no-prose"><style>.elmsh {color: #abb2bf;background: #282c34;}.elmsh-hl {background: rgba(229, 231,235, 0.1);}.elmsh-add {background: rgba(40, 124,82, 0.4);}.elmsh-del {background: rgba(136, 64,67, 0.4);}.elmsh-comm {font-style: italic;color: #5c6370;}.elmsh1 {color: #d19a66;}.elmsh2 {color: #98c379;}.elmsh3 {color: #c678dd;}.elmsh4 {color: #c678dd;}.elmsh5 {color: #61aeee;}.elmsh6 {color: #d19a66;}.elmsh7 {color: #abb2bf;}</style><pre class="elmsh"><code><div class="elmsh-line" data-elmsh-lc="1"><span class="elmsh-comm">{-|</span>
</div><div class="elmsh-line" data-elmsh-lc="2"><span class="elmsh-comm">Example: 5!</span>
</div><div class="elmsh-line" data-elmsh-lc="3">
</div><div class="elmsh-line" data-elmsh-lc="4"><span class="elmsh-comm">Token expectations:</span>
</div><div class="elmsh-line" data-elmsh-lc="5">
</div><div class="elmsh-line" data-elmsh-lc="6"><span class="elmsh-comm">    expr Bang</span>
</div><div class="elmsh-line" data-elmsh-lc="7"><span class="elmsh-comm">    ^^^^^^^^^ already parsed</span>
</div><div class="elmsh-line" data-elmsh-lc="8"><span class="elmsh-comm">-}</span>
</div><div class="elmsh-line" data-elmsh-lc="9"><span class="elmsh5 elmsh-elm-f">postfixBang</span> <span class="elmsh3 elmsh-elm-bs">:</span> <span class="elmsh4 elmsh-elm-ts">Expr</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Binop</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span> <span class="elmsh3 elmsh-elm-bs">-&gt;</span> <span class="elmsh4 elmsh-elm-ts">Maybe</span> (<span class="elmsh4 elmsh-elm-ts">Expr</span>, <span class="elmsh4 elmsh-elm-ts">List</span> <span class="elmsh4 elmsh-elm-ts">Token</span>)
</div><div class="elmsh-line" data-elmsh-lc="10"><span class="elmsh5 elmsh-elm-f">postfixBang</span> left op tokensAfterOp <span class="elmsh3 elmsh-elm-bs">=</span>
</div><div class="elmsh-line" data-elmsh-lc="11">    <span class="elmsh-comm">-- We&#039;re guaranteed to have parsed the `!` already</span>
</div><div class="elmsh-line" data-elmsh-lc="12">    <span class="elmsh-comm">-- Nothing to do here!</span>
</div><div class="elmsh-line" data-elmsh-lc="13">    <span class="elmsh6 elmsh-elm-c">Just</span> <span class="elmsh3 elmsh-elm-bs">(</span><span class="elmsh6 elmsh-elm-c">UnaryOp</span> <span class="elmsh6 elmsh-elm-c">Factorial</span> left<span class="elmsh4 elmsh-elm-gs">,</span> tokensAfterOp<span class="elmsh3 elmsh-elm-bs">)</span></div></code></pre></div><h2 id="conclusion"><a class="not-prose group " aria-label="Permalink for Conclusion" href="#conclusion"><span class="group-hover:underline decoration-primary-500">Conclusion</span><svg class="ph-icon text-primary-300 inline-block text-xl ml-2" fill="currentColor" height="1em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 256 256" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M236,88.12a50.44,50.44,0,0,1-14.81,34.31l-34.75,34.74A50.33,50.33,0,0,1,150.62,172h-.05A50.63,50.63,0,0,1,100,120a4,4,0,0,1,4-3.89h.11a4,4,0,0,1,3.89,4.11A42.64,42.64,0,0,0,150.58,164h0a42.32,42.32,0,0,0,30.14-12.49l34.75-34.74a42.63,42.63,0,1,0-60.29-60.28l-11,11a4,4,0,0,1-5.66-5.65l11-11A50.64,50.64,0,0,1,236,88.12ZM111.78,188.49l-11,11A42.33,42.33,0,0,1,70.6,212h0a42.63,42.63,0,0,1-30.11-72.77l34.75-34.74A42.63,42.63,0,0,1,148,135.82a4,4,0,0,0,8,.23A50.64,50.64,0,0,0,69.55,98.83L34.8,133.57A50.63,50.63,0,0,0,70.56,220h0a50.33,50.33,0,0,0,35.81-14.83l11-11a4,4,0,1,0-5.65-5.66Z"></path></svg></a></h2><p>Pratt parsers are nice in that they let you define a table of operators and their precedence levels, which they then work through: the traversal itself is abstracted away.</p><p>Pratt parsers <em>can</em> be shrouded in mystery (particularly if you encounter terms like <code>nud</code> and <code>led</code> while reading about them or using a library that didn&#039;t care to find better names).</p><p>With that in mind I hope I have demystified this technique a little bit and made you consider using or writing one. Life&#039;s too short to deal with operator precedence in an ad-hoc way!</p></article><div class="mt-8 border-t grid grid-cols-1 text-sm font-medium sm:grid-cols-2 sm:text-base"><div class="sm:col-start-1 flex flex-col mt-4 xl:mt-8"><span>Older post</span><a class="text-primary-700 dark:text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" elm-pages:prefetch="" href="/tech-blog/2019-10-01-an-introduction-to-elm">← An Introduction to Elm</a></div><div class="sm:col-start-2 flex flex-col sm:text-right mt-4 xl:mt-8"><span>Newer post</span><a class="text-primary-700 dark:text-primary-500 hover:text-primary-600 dark:hover:text-primary-400" elm-pages:prefetch="" href="/tech-blog/2023-09-06-simple-and-nice-elm-pages-blog">Simple and nice blogging template for elm‑pages →</a></div></div></div></main><footer class="mt-16 flex flex-col items-center"><div class="mb-2 flex space-x-2 text-sm text-gray-500 dark:text-gray-400"><div>Tomas Latal</div><div>•</div><div>© 2023</div><div>•</div><a class="hover:underline" href="/">elm blog</a></div><div class="mb-8 text-sm text-gray-500 dark:text-gray-400"><a class="hover:underline" href="https://github.com/kraklin/elm-pages-blog-starter" rel="noopener noreferrer" target="_blank">elm-pages blog template</a></div></footer></div></div>
  </body>
</html>